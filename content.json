{"meta":{"title":"bin","subtitle":"good good study,day day up","description":"good good study,day day up !!","author":null,"url":"http://blog.binvon.com","root":"/"},"pages":[{"title":"","date":"2021-10-06T14:13:16.750Z","updated":"2021-10-06T14:13:16.750Z","comments":true,"path":"search/index.html","permalink":"http://blog.binvon.com/search/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-10-06T13:29:04.595Z","updated":"2021-10-06T10:48:38.141Z","comments":true,"path":"categories/index.html","permalink":"http://blog.binvon.com/categories/index.html","excerpt":"","text":"type: “categories” comments: false"},{"title":"","date":"2021-10-06T16:49:51.315Z","updated":"2021-10-06T16:49:51.315Z","comments":true,"path":"about/index.html","permalink":"http://blog.binvon.com/about/index.html","excerpt":"","text":"一个热爱生活，热爱工作的90后Man"},{"title":"标签","date":"2021-10-06T13:29:44.998Z","updated":"2021-10-06T10:48:38.156Z","comments":true,"path":"tags/index.html","permalink":"http://blog.binvon.com/tags/index.html","excerpt":"","text":"type: “tags” comments: false"}],"posts":[{"title":"java的泛型","slug":"java的泛型","date":"2021-07-04T18:26:54.000Z","updated":"2021-10-07T02:31:57.310Z","comments":true,"path":"2021/07/05/java的泛型/","link":"","permalink":"http://blog.binvon.com/2021/07/05/java%E7%9A%84%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"一、概述Java泛型（generics）是JDK 5中引入的一个新特性，泛型提供了编译时类型安全监测机制，该机制允许程序员在编译时监测非法的类型。使用泛型机制编写的程序代码要比那些杂乱地使用Object变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。泛型对于集合类尤其有用，例如，ArrayList就是一个无处不在的集合类。 泛型的本质是参数化类型，也就是所操作的数据类型被指定为一个参数。 二、泛型的使用泛型有三种常用的使用方式：泛型类，泛型接口和泛型方法。下面讲一一简单介绍这三种使用方法： 泛型类一个泛型类（generic class）就是具有一个或多个类型变量的类。下面通过一个简单的Pair类作为例子。对于这个类来说，我们只关注泛型，而不会为数据存储的细节烦恼。下面是Pair类的代码： 12345678910111213141516171819202122232425262728293031323334/* * 泛型类 * Java库中 E表示集合的元素类型，K 和 V分别表示表的关键字与值的类型 * T（需要时还可以用临近的字母 U 和 S）表示“任意类型” */public class Pair&lt;T&gt; &#123; private T name; private T price; public Pair() &#123; &#125; public Pair(T name, T price) &#123; this.name = name; this.price = price; &#125; public T getName() &#123; return name; &#125; public void setName(T name) &#123; this.name = name; &#125; public T getPrice() &#123; return price; &#125; public void setPrice(T price) &#123; this.price = price; &#125;&#125; Pair类引入了一个类型变量T，用尖括号（&lt;&gt;）括起来，并放在类名的后面。泛型类可以有多个类型变量。例如，可以定义Pair类，其中第一个域和第二个域使用不同的类型： 1public class Pair&lt;T,U&gt; &#123; ... &#125; 类方法中的类型变量指定方法的返回类型以及域和局部变量的类型。例如： 1private T first; //uses the type variable 用具体的类型替换类型变量就可以实例化泛型类型，例如： 1Pair&lt;String&gt; 可以将结果想象成带有构造器的普通类： 12Pair&lt;String&gt;()Pair&lt;String&gt;(String,String) 和方法： 1234String getName()String getPrice()void setName(String)void setPrice(String) 泛型接口12345public interface Generator&lt;T&gt; &#123; public T next();&#125; 继承接口： 12345678public class FruitGenerator implements Generator&lt;String&gt; &#123; @Override public String next() &#123; return &quot;Fruit&quot;; &#125;&#125; 或者也可以这样： 12345678910111213141516171819public class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt; &#123; private T next; public FruitGenerator(T next) &#123; this.next = next; &#125; @Override public T next() &#123; return next; &#125; public static void main(String[] args)&#123; FruitGenerator&lt;String&gt; fruit = new FruitGenerator&lt;&gt;(&quot;Fruit&quot;); System.out.println(fruit.next); &#125;&#125; 泛型方法12345678910public class ArrayAlg &#123; public static &lt;T&gt; T getMiddle(T... a) &#123; return a[a.length / 2]; &#125; public static void main(String[] args)&#123; System.out.println(ArrayAlg.getMiddle(1,2,3,4,5)); &#125;&#125; 这个方法是在普通类中定义的，而不是在泛型类中定义的。然而，这是一个泛型方法，可以从尖括号和类型变量看出这一点。注意，类型变量放在修饰符（这里是 public static）的后面，返回类型的前面。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/tags/java/"}]},{"title":"使用goolge cloud建设ssr","slug":"使用goolge-cloud建设ssr","date":"2019-12-29T08:40:12.000Z","updated":"2021-10-06T17:43:04.720Z","comments":true,"path":"2019/12/29/使用goolge-cloud建设ssr/","link":"","permalink":"http://blog.binvon.com/2019/12/29/%E4%BD%BF%E7%94%A8goolge-cloud%E5%BB%BA%E8%AE%BEssr/","excerpt":"","text":"yum -y install wget wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh chmod +x shadowsocksR.sh ./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log ———————————————————代码分割线————输入每行回车设置密码13231端口236","categories":[],"tags":[{"name":"vpn","slug":"vpn","permalink":"http://blog.binvon.com/tags/vpn/"}]},{"title":"生成分布式ID算法.","slug":"生成分布式ID算法","date":"2018-08-04T18:11:22.000Z","updated":"2018-08-10T15:03:42.000Z","comments":true,"path":"2018/08/05/生成分布式ID算法/","link":"","permalink":"http://blog.binvon.com/2018/08/05/%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8FID%E7%AE%97%E6%B3%95/","excerpt":"","text":"一、分布式ID 1. 为什么需要分布式全局唯一ID？ 在复杂的分布式系统中，往往需要对大量的数据和消息进行唯一标识。如在美团点评的金融、支付、餐饮、酒店等产品的系统中数据日渐增长，对数据分库分表后需要有一个唯一ID来标识某一条数据或消息，此时一个能够生成全局唯一ID的系统是非常必要的。 2. 那么分布式ID生成需要满足哪些条件 全局唯一：分布式系统下必须要保证ID是全局唯一的，这是最基本的要求； 高性能：高可用低延时，ID生成响应要快，否则反倒会成为业务瓶颈； 高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用； 好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单； 趋势递增：由于多数公司使用的是MySQL InnoDB作为存储引擎，所以ID最好趋势递增。 二、一般通用方案 1. UUID String uuid = UUID.randomUUID().toString().replaceAll(“-“,””); UUID的标准形式：包含32个16进制数字，以连字号分为五段，形式为8-4-4-12的36个字符； 优点：代码简单，性能非常高（本地生成，没有网络消耗），保证唯一（重复概率极低可以忽略）； 缺点：生成的ID是无序的字符串，无法保证趋势递增，且没有一定的业务含义；还有就是长度过长入且无序，会严重消耗MySQL数据库性能。 为什么无序的UUID会导致入库性能变差呢？ 作为主键过长，MySQL官方有明确的建议主键尽量越短越好，36个字符长度的UUID不符合要求； 字符串且无序，MySQL InnoDB引擎的索引底层数据结构是B+树，每一次新的UUID插入表，都会对主键底层的B+树索引进行很大的修改，插入完全无序，不但会导致一些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能，还会增加读取磁盘的次数。 2. 数据库自增主键 单点模式自增ID 在分布式里，数据库的自增ID机制的主要原理是：数据库自增ID和MySql数据库的replace into实现的。 replace into 跟 insert 功能类似，不同点在于：replace into首先尝试插入数据列表中，如果发现表中已经有此行数据（根据主键或唯一索引）判断是否存在，若有则先删除再插入，否则直接插入新数据。REPLACE INTO的含义是插入一条记录，如果表中唯一索引的值遇到冲突，则替换老数据。 CREATE TABLE t_test ( id bigint(20) unsigned not null auto_increment primary key, stub char(1) not null default ‘’, unique key stub (stub) ) select * from t_test; replace into t_test (stub) values(‘a’); select last_insert_id(); 当我们需要一个ID时，向表中插入一条记录返回主键ID即可。此种方式优点：实现简单，ID单调自增，数值类型查询速度快；缺点：1）强依赖DB，存在单点问题，一旦数据库宕机，整个业务不可用；2）单点数据库压力大，无法扛住高并发场景；3）信息安全问题，比如暴露订单量等。 集群式自增ID 对上面单点模式做优化，改成集群模式自增ID，也就是多个MySQL实例各自生成自增ID。要设置起始值和自增步长，保证生成ID不会重复。 优点：解决了ID生成的单点问题，同时平衡了负载； 缺点：系统后续水平扩容比较困难，增加机器可能要修改步长，起始值也不容易设置。数据库压力还是很大，每次获取ID都得读写一次数据库，非常影响性能，依旧无法满足高并发场景。 3. 基于Redis生成全局ID策略 因为Redis是单线程的天生保证原子性， 利用Redis的incr命令实现ID的原子性自增。 127.0.0.1:6379&gt; set seq_id 1 // 初始化自增ID为1 OK 127.0.0.1:6379&gt; incr seq_id // 增加1，并返回递增后的数值 (integer) 2 集群分布式，可以使用Redis集群来获取更高的吞吐量，注意：在Redis集群情况下，同样和MySql一样需要设置不同的增长步长，同时key一定要设置有效期。 假如一个集群中有5台Redis，可以初始化每台Redis的值分别是1，2，3，4，5 然后步长都是5，每个redis生成的ID为： ​ A：1、6、11、16、21 B：2、7、12、17、22 C：3、8、13、18、23 D：4、9、14、19、24 E：5、10、15、20、25 优点：效率高，不依赖数据库，可以扛住高并发场景； 缺点：要考虑Redis的持久化问题，Redis支持RDB和AOF两种持久化的方式。 RDB会定时打一个快照，如果打完快照后，连续自增了几次，还没来得及做下一次快照持久化，此时Redis挂掉了，重启Redis后会出现ID重复的情况。 AOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现ID重复的情况，但是由于incr命令的特殊性，会导致Redis重启恢复数据时间过长。 三、雪花算法 - Snowflake 1. 概述 Twitter的分布式ID生成算法，开源后广受国内大厂的好评，经测试snowflake每秒能够生产26万个自增可排序的ID。 特点： 生成结果是一个64bit大小的Long类型整数； 生成ID能够按照时间有序生成； 不会产生ID碰撞并且效率较高。 2. 结构 结构：符号位（1bit）+ 时间戳（41bit）+ 机器ID（5bit）+ 数据中心（5bit）+ 自增序列号（12bit） 符号位：Java中Long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0； 时间戳：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L 60 60 24 365) = 69年； 工作机器ID：用来记录工作机器ID。可以部署 2^{10} = 1024个节点，包括5位datacenterId和5位workerId。可以灵活配置，机房或者机器号组合都可以； 序列号：自增值，支持同一毫秒内同一个节点（同一个机器）可以生成4096个ID。 因为时间戳是递增的，序列号也是递增的，所以雪花算法可以保证所有生成的ID按时间趋势递增，整个分布式系统内不会产生重复ID（因为有 datacenterId 和 workId来做区分）。 3. 源码 Java版(Hutool)： /** * Twitter的Snowflake 算法 * 分布式系统中，有一些需要使用全局唯一ID的场景，有些时候我们希望能使用一种简单一些的ID，并且希望ID能够按照时间有序生成。 * * * snowflake的结构如下(每部分用-分开): * * * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 * * * 第一位为未使用(符号位表示正数)，接下来的41位为毫秒级时间(41位的长度可以使用69年) * 然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点） * 最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号） * * 并且可以通过生成的id反推出生成时间,datacenterId和workerId * * 参考：http://www.cnblogs.com/relucent/p/4955340.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990`/* * @author Looly ``* @since 3.0.1 */ ``public class Snowflake implements Serializable &#123; private static final long serialVersionUID = 1L; // 开始时间戳 private final long twepoch; // 机器标识位数 private final long workerIdBits = 5L; // 数据中心标识位数 private final long dataCenterIdBits = 5L; // 最大支持机器节点数0~31，一共32个 最大支持数据中心节点数0~31，一共32个 @SuppressWarnings(&#123;&quot;PointlessBitwiseExpression&quot;, &quot;FieldCanBeLocal&quot;&#125;) private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); @SuppressWarnings(&#123;&quot;PointlessBitwiseExpression&quot;, &quot;FieldCanBeLocal&quot;&#125;) private final long maxDataCenterId = -1L ^ (-1L &lt;&lt; dataCenterIdBits); // 序列号12位 private final long sequenceBits = 12L; // 机器节点左移12位 private final long workerIdShift = sequenceBits; // 数据中心节点左移17位 private final long dataCenterIdShift = sequenceBits + workerIdBits; // 时间毫秒数左移22位 private final long timestampLeftShift = sequenceBits + workerIdBits + dataCenterIdBits; @SuppressWarnings(&#123;&quot;PointlessBitwiseExpression&quot;, &quot;FieldCanBeLocal&quot;&#125;) private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);// 4095 private final long workerId; private final long dataCenterId; private final boolean useSystemClock; private long sequence = 0L; private long lastTimestamp = -1L; /** * 构造 * * @param workerId 终端ID * @param dataCenterId 数据中心ID */ public Snowflake(long workerId, long dataCenterId) &#123; this(workerId, dataCenterId, false); &#125; /** * 构造 * * @param workerId 终端ID * @param dataCenterId 数据中心ID * @param isUseSystemClock 是否使用 &#123;@link SystemClock&#125; 获取当前时间戳 */ public Snowflake(long workerId, long dataCenterId, boolean isUseSystemClock) &#123; this(null, workerId, dataCenterId, isUseSystemClock); &#125; /** * @param epochDate 初始化时间起点（null表示默认起始日期）,后期修改会导致id重复,如果要修改连workerId dataCenterId，慎用 * @param workerId 工作机器节点id * @param dataCenterId 数据中心id * @param isUseSystemClock 是否使用&#123;@link SystemClock&#125; 获取当前时间戳 * @since 5.1.3 */ public Snowflake(Date epochDate, long workerId, long dataCenterId, boolean isUseSystemClock) &#123; if (null != epochDate) &#123; this.twepoch = epochDate.getTime(); &#125; else &#123; // Thu, 04 Nov 2010 01:42:54 GMT this.twepoch = 1288834974657L; &#125; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format(&quot;worker Id can&#x27;t be greater than &#123;&#125;&#125; or less than 0&quot;, maxWorkerId)); &#125; if (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; 0) &#123; throw new IllegalArgumentException(String.format(&quot;datacenter Id can&#x27;t be greater than &#123;&#125; or less than 0&quot;, maxDataCenterId)); &#125; this.workerId = workerId; this.dataCenterId = dataCenterId; this.useSystemClock = isUseSystemClock; &#125; /** * 根据Snowflake的ID，获取机器id * * @param id snowflake算法生成的id * @return 所属机器的id */ public long getWorkerId(long id) &#123; return id &gt;&gt; workerIdShift &amp; ~(-1L &lt;&lt; workerIdBits); &#125; /** * 根据Snowflake的ID，获取数据中心id * * @param id snowflake算法生成的id * @return 所属数据中心 */ public long getDataCenterId(long id) &#123; return id &gt;&gt; dataCenterIdShift &amp; ~(-1L &lt;&lt; dataCenterIdBits); &#125; /** * 根据Snowflake的ID，获取生成时间 * * @param id snowflake算法生成的id * @return 生成的时间 */ public long getGenerateDateTime(long id) &#123; return (id &gt;&gt; timestampLeftShift &amp; ~(-1L &lt;&lt; 41L)) + twepoch; &#125; /** * 下一个ID * * @return ID */ public synchronized long nextId() &#123; long timestamp = genTime(); if (timestamp &lt; lastTimestamp) &#123; // 如果服务器时间有问题(时钟后退) 报错。 throw new IllegalStateException(String.format(&quot;Clock moved backwards. Refusing to generate id for &#123;&#125;ms&quot;, (lastTimestamp - timestamp))); &#125; if (lastTimestamp == timestamp) &#123; sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) &#123; timestamp = tilNextMillis(lastTimestamp); &#125; &#125; else &#123; sequence = 0L; &#125; lastTimestamp = timestamp; return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (dataCenterId &lt;&lt; dataCenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; &#125; /** * 下一个ID（字符串形式） * * @return ID 字符串形式 */ public String nextIdStr() &#123; return Long.toString(nextId()); &#125; // ------------------------------------------------------------------------------------------------------------------------------------ Private method start /** * 循环等待下一个时间 * * @param lastTimestamp 上次记录的时间 * @return 下一个时间 */ private long tilNextMillis(long lastTimestamp) &#123; long timestamp = genTime(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = genTime(); &#125; return timestamp; &#125; /** * 生成时间戳 * * @return 时间戳 */ private long genTime() &#123; return this.useSystemClock ? SystemClock.now() : System.currentTimeMillis(); &#125; &#125;` 4. 工程落地经验 分布式整合雪花算法： IdGenerateInvoker.java /** * 分布式环境下数据库主键的ID生成器 * 实现了对分布式友好的Snowflake算法，并且会在Spring IOC容器初始化的时候注册成为单例Bean. * 如果需要自定义生成策略，请实现本接口并将其实例注册到容器中，并在{@link PrimaryKey}的strategy属性指定. * / public interface IdGenerateInvoker { /* * 获取下一个永不重复的id. * * @return id. */ Serializable nextId(); } SnowFlakeIdGenerateInvoker.java /** * ======分布式数据库主键ID生成器基于SnowFlake算法的实现. * 本实现类的对象将会在程序启动的时候自动在Spring IOC容器中注册为Bean. * 如果想在您的持久化过程中由系统自动设置主键字段的值，只需要在具体的POJO字段上添加@PrimaryKey注解，详见{@link PrimaryKey}. * 其默认打开，并且在未指定具体id生成算法的前提下，它将自动使用SnowFlake算法生成id,在持久化之前自动设置值. * * SnowFlake算法的实现依赖于workerId和dataCenterId两个值的，系统默认使用5L作为其初始值. * 如果您想要在分布式环境使用本算法的实现，建议您在application.yml中配置这2个属性的值. */ @Component public class SnowFlakeIdGenerateInvoker implements IdGenerateInvoker { @Autowired private SnowFlakeConfig snowFlakeConfig; private Snowflake snowflake; @PostConstruct public void init() { long wokerid = snowFlakeConfig.getWorkerId(); long dataCenterId = snowFlakeConfig.getDataCenterId(); this.snowflake = new Snowflake(wokerid, dataCenterId); } @Override public synchronized Serializable nextId() { return snowflake.nextId(); } } SnowFlakeConfig.java 公司workerId使用位长为8位，取的是机器IP地址后三位； dataCenterId使用位长为两位，配置在配置文件中。 /** * 关于SnowFlake的配置. * WorkerId和DataCenterId的值请保证集群中的每个节点不相同. * WorkerId取ip地址最后三位，dataCenterId配置在properties. */ @Component @Validated @Slf4j @ConfigurationProperties(prefix = “snowflake”) public class SnowFlakeConfig { @Value(“${spring.application.name}”) private String appName; private long workerId; @NotNull private long dataCenterId; @PostConstruct public void init() { try { String ipAddr = NetUtil.getHostIpAddr(); log.info(“current ip :{}”, ipAddr); if (!StringUtils.isEmpty(ipAddr)) { String[] ipStep = ipAddr.split(“\\.”); this.workerId = Long.valueOf(ipStep[3]); } else { log.warn(“ip address parse error.”); } } catch (Exception e) { throw new RuntimeException(e); } log.info(“Snowflake:[workerId:{} from ip address tail, dataCenterId:{} from properties] of micro service [{}] has been initialized.” , workerId, dataCenterId, appName == null ? “” : appName.toUpperCase()); } public long getWorkerId() { return workerId; } public void setWorkerId(long workerId) { this.workerId = workerId; } public long getDataCenterId() { return dataCenterId; } public void setDataCenterId(long dataCenterId) { this.dataCenterId = dataCenterId; } } application.properties spring.application.name=ncs-case # snowflake配置 #snowflake.worker-id= snowflake.data-center-id=2 5. 雪花算法优缺点 优点： 毫秒数在高位，自增序列在低位，整个ID都是趋势递增的； 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的； 可以根据自身业务特性分配bit位，非常灵活。 缺点： 依赖机器时钟，如果机器时钟回拨，会导致重复ID生成； 在单机上是递增的，但是由于设计到分布式环境，每台机器上的时钟不可能完全同步，有时候会出现不是全局递增的情况（此缺点可以认为无所谓，一般分布式ID只要求趋势递增，并不会严格要求递增，90%的需求都只要求趋势递增）。 补充解决时钟回拨思路：因为机器的原因会发生时间回拨，我们的雪花算法是强依赖机器时间的，如果时间发生回拨，有可能会生成重复的ID，在我们上面的nextId中用当前时间和上一次的时间进行判断，如果当前时间小于上一次的时间那么肯定是发生了回拨，普通的算法会直接抛出异常。这里我们可以对其进行优化，一般分为两个情况： 如果时间回拨时间较短，比如配置5ms以内，那么可以直接等待一定的时间，让机器时间追上来； 如果时间的回拨时间较长，我们不能接受这么长的阻塞等待，那么又有两个策略，直接拒绝，抛出异常，打日志，或者通知RD时钟回滚。 四、其他方式 百度开源的分布式唯一ID生成器UidGenerator 美团点评分布式ID生成系统 Leaf","categories":[{"name":"分布式","slug":"分布式","permalink":"http://blog.binvon.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://blog.binvon.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"Java两种方式实现Token校验","slug":"Java实现基于token认证的方法示例","date":"2017-06-08T01:11:22.000Z","updated":"2017-06-10T15:03:42.000Z","comments":true,"path":"2017/06/08/Java实现基于token认证的方法示例/","link":"","permalink":"http://blog.binvon.com/2017/06/08/Java%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8Etoken%E8%AE%A4%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B/","excerpt":"","text":"一、与cookie相比较的优势： 1、支持跨域访问，将token置于请求头中，而cookie是不支持跨域访问的； 2、无状态化，服务端无需存储token，只需要验证token信息是否正确即可，而session需要在服务端存储，一般是通过cookie中的sessionID在服务端查找对应的session； 3、无需绑定到一个特殊的身份验证方案（传统的用户名密码登陆），只需要生成的token是符合我们预期设定的即可； 4、更适用于移动端（Android，iOS，小程序等等），像这种原生平台不支持cookie，比如说微信小程序，每一次请求都是一次会话，当然我们可以每次去手动为他添加cookie，详情请查看博主另一篇博客； 5、避免CSRF跨站伪造攻击，还是因为不依赖cookie； 6、非常适用于RESTful API,这样可以轻易与各种后端（java，.net，python……）相结合，去耦合 还有一些优势这里就不一一列举了。 二、基于JWT的token认证实现 JWT：JSON Web Token，其实token就是一段字符串，由三部分组成：Header，Payload，Signature。详细情况请自行百度，现在，上代码。 1、引入依赖，这里选用java-jwt，选择其他的依赖也可以 2、实现签名方法 设置15分钟过期也是出于安全考虑，防止token被窃取，不过一般选择基于token认证，传输方式我们都应该选择https，这样别人无法抓取到我们的请求信息。这个私钥是非常重要的，加密解密都需要用到它，要设置的足够复杂并且不能被盗取，我这里选用的是一串uuid，加密方式是HMAC256。 3、认证 我这里演示的还是以传统的用户名密码验证，验证通过发放token。 **4、配置拦截器 实现HandleInterceptor，重写preHandle方法，该方法是在每个请求之前触发执行，从request的头里面取出token，这里我们统一了存放token的键为accessToken，验证通过，放行，验证不通过，返回认证失败信息。 5、设置拦截器 这里使用的是Spring的xml配置拦截器，放过认证接口。 6、token解码方法 7、测试 访问携带token，请求成功。 未携带token或者token错误，过期，返回认证失败信息。 8、获取token里携带的信息 我们可以将一些常用的信息放入token中，比如用户登陆信息，可以方便我们的使用 至此，一个简单的基于token认证就实现了.","categories":[{"name":"auth","slug":"auth","permalink":"http://blog.binvon.com/categories/auth/"}],"tags":[{"name":"auth","slug":"auth","permalink":"http://blog.binvon.com/tags/auth/"}]},{"title":"can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1:","slug":"can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-at-line-4-column-1","date":"2015-09-10T08:00:11.000Z","updated":"2015-09-10T15:03:42.000Z","comments":true,"path":"2015/09/10/can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-at-line-4-column-1/","link":"","permalink":"http://blog.binvon.com/2015/09/10/can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-at-line-4-column-1/","excerpt":"","text":"无法读取块映射项;多行键可能不是第4行第1列的隐式键: 我是新建一篇博客时、编译出现的错误。其实我之前一直不配置tags的。这里的”:”后面还是要接上空格。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.binvon.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.binvon.com/tags/hexo/"}]},{"title":"BIO,NIO,AIO 有什么区别","slug":"BIO-NIO-AIO-有什么区别","date":"2015-08-04T18:11:22.000Z","updated":"2015-08-10T15:03:42.000Z","comments":true,"path":"2015/08/05/BIO-NIO-AIO-有什么区别/","link":"","permalink":"http://blog.binvon.com/2015/08/05/BIO-NIO-AIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","excerpt":"","text":"BIO （Blocking I/O）：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。这里使用那个经典的烧开水例子，这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。 NIO （New I/O）：同时支持阻塞与非阻塞模式，但这里我们以其同步非阻塞I/O模式来说明，那么什么叫做同步非阻塞？如果还拿烧开水来说，NIO的做法是叫一个线程不断的轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。 AIO （ Asynchronous I/O）：异步非阻塞I/O模型。异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。 进程中的IO调用步骤大致可以分为以下四步： 进程向操作系统请求数据 ; 操作系统把外部数据加载到内核的缓冲区中; 操作系统把内核的缓冲区拷贝到进程的缓冲区 ; 进程获得数据完成自己的功能 ; 当操作系统在把外部数据放到进程缓冲区的这段时间（即上述的第二，三步），如果应用进程是挂起等待的，那么就是同步IO，反之，就是异步IO，也就是AIO 。","categories":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/tags/java/"}]},{"title":"continue,break,return有什么区别","slug":"continue-break-return有什么区别","date":"2015-07-11T18:23:42.000Z","updated":"2015-07-12T15:03:42.000Z","comments":true,"path":"2015/07/12/continue-break-return有什么区别/","link":"","permalink":"http://blog.binvon.com/2015/07/12/continue-break-return%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1、return ：直接跳出当前的方法,返回到该调用的方法的语句处,继续执行 2、break：在循环体内结束整个循环过程 3、continue ：结束本次的循环，直接进行下一次的循环","categories":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/tags/java/"}]},{"title":"JDK安装与环境变量配置","slug":"JDK安装与环境变量配置","date":"2015-07-10T08:23:43.000Z","updated":"2015-07-10T15:03:42.000Z","comments":true,"path":"2015/07/10/JDK安装与环境变量配置/","link":"","permalink":"http://blog.binvon.com/2015/07/10/JDK%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/","excerpt":"","text":"工具/原料 JDK1.7.0 WIN7 方法/步骤 一、安装JDK 选择安装目录 安装过程中会出现两次 安装提示 。第一次是安装 jdk ，第二次是安装 jre 。 建议两个都安装在同一个java文件夹中的不同文件夹中。 （不能都安装在java文件夹的根目录下，jdk和jre安装在同一文件夹会出错）如下图所示 二、1：安装jdk 随意选择目录 只需把默认安装目录 \\java 之前的目录修改即可 2：安装jre→更改→ \\java 之前目录和安装 jdk 目录相同即可 注：若无安装目录要求，可全默认设置。无需做任何修改，两次均直接点下一步。 三、安装完JDK后配置环境变量 计算机→属性→高级系统设置→高级→环境变量 四、系统变量→新建 JAVA_HOME 变量 。 变量值填写jdk的安装目录（本人是 E:\\Java\\jdk1.7.0)五、系统变量→寻找 Path 变量→编辑 在变量值最后输入 %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; （注意原来Path的变量值末尾有没有;号，如果没有，先输入；号再输入上面的代码） 六、系统变量→新建 CLASSPATH 变量 变量值填写 .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar（注意最前面有一点） 系统变量配置完毕 七、检验是否配置成功 运行cmd 输入 java -version （java 和 -version 之间有空格） 若如图所示 显示版本信息 则说明安装和配置成功。","categories":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/tags/java/"}]},{"title":"CentOS7查看最大线程数","slug":"CentOS7查看最大线程数","date":"2015-07-10T08:23:43.000Z","updated":"2019-10-22T15:03:42.000Z","comments":true,"path":"2015/07/10/CentOS7查看最大线程数/","link":"","permalink":"http://blog.binvon.com/2015/07/10/CentOS7%E6%9F%A5%E7%9C%8B%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%95%B0/","excerpt":"","text":"aaaa","categories":[{"name":"服务器","slug":"服务器","permalink":"http://blog.binvon.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.binvon.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]}],"categories":[{"name":"分布式","slug":"分布式","permalink":"http://blog.binvon.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"auth","slug":"auth","permalink":"http://blog.binvon.com/categories/auth/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.binvon.com/categories/hexo/"},{"name":"java","slug":"java","permalink":"http://blog.binvon.com/categories/java/"},{"name":"服务器","slug":"服务器","permalink":"http://blog.binvon.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/tags/java/"},{"name":"vpn","slug":"vpn","permalink":"http://blog.binvon.com/tags/vpn/"},{"name":"分布式","slug":"分布式","permalink":"http://blog.binvon.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"auth","slug":"auth","permalink":"http://blog.binvon.com/tags/auth/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.binvon.com/tags/hexo/"},{"name":"服务器","slug":"服务器","permalink":"http://blog.binvon.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]}