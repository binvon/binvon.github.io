{"meta":{"title":"bin","subtitle":"good good study,day day up","description":"good good study,day day up !!","author":null,"url":"http://blog.binvon.com","root":"/"},"pages":[{"title":"","date":"2021-10-06T14:13:16.750Z","updated":"2021-10-06T14:13:16.750Z","comments":true,"path":"search/index.html","permalink":"http://blog.binvon.com/search/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-10-06T13:29:04.595Z","updated":"2021-10-06T10:48:38.141Z","comments":true,"path":"categories/index.html","permalink":"http://blog.binvon.com/categories/index.html","excerpt":"","text":"type: “categories” comments: false"},{"title":"标签","date":"2021-10-06T13:29:44.998Z","updated":"2021-10-06T10:48:38.156Z","comments":true,"path":"tags/index.html","permalink":"http://blog.binvon.com/tags/index.html","excerpt":"","text":"type: “tags” comments: false"},{"title":"","date":"2021-10-06T16:49:51.315Z","updated":"2021-10-06T16:49:51.315Z","comments":true,"path":"about/index.html","permalink":"http://blog.binvon.com/about/index.html","excerpt":"","text":"一个热爱生活，热爱工作的90后Man"}],"posts":[{"title":"java的泛型","slug":"java的泛型","date":"2021-07-04T18:26:54.000Z","updated":"2021-10-07T03:37:11.290Z","comments":true,"path":"2021/07/05/java的泛型/","link":"","permalink":"http://blog.binvon.com/2021/07/05/java%E7%9A%84%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"一、概述Java泛型（generics）是JDK 5中引入的一个新特性，泛型提供了编译时类型安全监测机制，该机制允许程序员在编译时监测非法的类型。使用泛型机制编写的程序代码要比那些杂乱地使用Object变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。泛型对于集合类尤其有用，例如，ArrayList就是一个无处不在的集合类。 泛型的本质是参数化类型，也就是所操作的数据类型被指定为一个参数。 二、泛型的使用泛型有三种常用的使用方式：泛型类，泛型接口和泛型方法。下面讲一一简单介绍这三种使用方法： 泛型类一个泛型类（generic class）就是具有一个或多个类型变量的类。下面通过一个简单的Pair类作为例子。对于这个类来说，我们只关注泛型，而不会为数据存储的细节烦恼。下面是Pair类的代码： 12345678910111213141516171819202122232425262728293031323334/* * 泛型类 * Java库中 E表示集合的元素类型，K 和 V分别表示表的关键字与值的类型 * T（需要时还可以用临近的字母 U 和 S）表示“任意类型” */public class Pair&lt;T&gt; &#123; private T name; private T price; public Pair() &#123; &#125; public Pair(T name, T price) &#123; this.name = name; this.price = price; &#125; public T getName() &#123; return name; &#125; public void setName(T name) &#123; this.name = name; &#125; public T getPrice() &#123; return price; &#125; public void setPrice(T price) &#123; this.price = price; &#125;&#125; Pair类引入了一个类型变量T，用尖括号（&lt;&gt;）括起来，并放在类名的后面。泛型类可以有多个类型变量。例如，可以定义Pair类，其中第一个域和第二个域使用不同的类型： 1public class Pair&lt;T,U&gt; &#123; ... &#125; 类方法中的类型变量指定方法的返回类型以及域和局部变量的类型。例如： 1private T first; //uses the type variable 用具体的类型替换类型变量就可以实例化泛型类型，例如： 1Pair&lt;String&gt; 可以将结果想象成带有构造器的普通类： 12Pair&lt;String&gt;()Pair&lt;String&gt;(String,String) 和方法： 1234String getName()String getPrice()void setName(String)void setPrice(String) 泛型接口12345public interface Generator&lt;T&gt; &#123; public T next();&#125; 继承接口： 12345678public class FruitGenerator implements Generator&lt;String&gt; &#123; @Override public String next() &#123; return &quot;Fruit&quot;; &#125;&#125; 或者也可以这样： 12345678910111213141516171819public class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt; &#123; private T next; public FruitGenerator(T next) &#123; this.next = next; &#125; @Override public T next() &#123; return next; &#125; public static void main(String[] args)&#123; FruitGenerator&lt;String&gt; fruit = new FruitGenerator&lt;&gt;(&quot;Fruit&quot;); System.out.println(fruit.next); &#125;&#125; 泛型方法12345678910public class ArrayAlg &#123; public static &lt;T&gt; T getMiddle(T... a) &#123; return a[a.length / 2]; &#125; public static void main(String[] args)&#123; System.out.println(ArrayAlg.getMiddle(1,2,3,4,5)); &#125;&#125; 这个方法是在普通类中定义的，而不是在泛型类中定义的。然而，这是一个泛型方法，可以从尖括号和类型变量看出这一点。注意，类型变量放在修饰符（这里是 public static）的后面，返回类型的前面。","categories":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/tags/java/"}]},{"title":"Linux下安装Consul","slug":"Linux下安装Consul","date":"2020-08-08T18:11:22.000Z","updated":"2020-08-10T15:03:42.000Z","comments":true,"path":"2020/08/09/Linux下安装Consul/","link":"","permalink":"http://blog.binvon.com/2020/08/09/Linux%E4%B8%8B%E5%AE%89%E8%A3%85Consul/","excerpt":"","text":"1. 下载consul 下载：[ https://www.consul.io/downloads.html] 下载安装包linux版本，手动使用FTP工具上传至安装目录 2. 安装 ​ consul不需要安装，将按下的zip包解压即可。 \\1) 创建consul目录 mkdir consul \\2) 解压已经下载的压缩包consul_1.4.0_linux_amd64.zip到consul目录中 unzip consul_1.4.0_linux_amd64.zip -d ./consule/ 可以看到有一个名为consul的文件，如下： 3. 启动 启动命令： nohup ./consul agent -server -bootstrap -bind=127.0.0.1 -client 0.0.0.0 -ui -data-dir=./data/ &gt;&gt; consul.log 2&gt;&amp;1 &amp; 参数说明： -server：以服务的形式启动 -bootstrap：自选举 -bind：本地环境的ip地址 -client 0.0.0.0 ：允许除本地的127.0.0.1之外的客户端访问 -ui：使用web界面访问和管理consul -data-dir：数据的存储目录 &gt;&gt;之后：将日志重定向到consul.log的日志文件中 部分日志： 4. 使用 服务启动后，我们可以使用web页面来访问consul，在浏览器输入：http://172.26.32.208:8500/ui/即可访问。如图： 可以使用postman（其他工具）、命令行来设置kv数据: \\1) postman示例： \\2) 命令行： 参考：https://www.consul.io/docs/commands/kv.html 5. 备份 \\1) 源consul数据导出 # ./consul kv export –http-addr=http://192.168.0.226:8500 -token=b3a9bca3-6e8e-9678-ea35-ccb8fb272d42 ‘’ &gt; consul_kv_dnps.json \\2) 源consul数据拷贝远程服务器指定目录下 # scp /opt/consul/consul_kv_dnps.json &#x72;&#x6f;&#x6f;&#116;&#64;&#51;&#x39;&#x2e;&#x39;&#x31;&#x2e;&#x32;&#48;&#x30;&#x2e;&#x31;&#x38;&#x33;:/opt/consul/consul_kv_dnps.json \\3) 源consul数据导入 # ./consul kv import –http-addr=http://192.168.0.226:8500 -token=b3a9bca3-6e8e-9678-ea35-ccb8fb272d42 @consul_kv_dnps.json","categories":[{"name":"分布式","slug":"分布式","permalink":"http://blog.binvon.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://blog.binvon.com/tags/springcloud/"},{"name":"consul","slug":"consul","permalink":"http://blog.binvon.com/tags/consul/"}]},{"title":"Consul集群Server+Client模式","slug":"Consul集群Server-Client模式","date":"2020-08-05T05:18:27.000Z","updated":"2020-08-10T15:03:42.000Z","comments":true,"path":"2020/08/05/Consul集群Server-Client模式/","link":"","permalink":"http://blog.binvon.com/2020/08/05/Consul%E9%9B%86%E7%BE%A4Server-Client%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"Consul集群Server+Client模式 架构示意图 只使用Consul的Server模式有以下2个问题： 因为Consul Server数量受到控制所以压力承载（扩展性）是个问题。 Server很少导致一个Server下会注册很多微服务，当Server挂掉，这个Server节点下注册的微服务都会视为无效。 基于上述问题我们在架构中加入Consul Client模式，Client因为加入了LAN gossip协议组成网络中（高速局域网），可以识别故障的Server节点并找到可用的Server节点继续工作，其实Server模式负责的是用WAN gossip协议组成的网络进行跨广域网的数据同步（多个数据中心），这点Client模式是做不到的，Client模式也提供服务的注册和查询，但Client模式不存储节点数据，Client将请求转发给Server进行处理，节点注册数据在Server端是持久化保存的，Client的数量可以无限多，Server的数量是受控制的。总之：Client模式+LAN gossip协议组成了一个数据中心中的各个节点，Server负责投票选出Leader进行数据中心内的数据同步，这个Leader还负责利用WAN gossip协议跨广域网的与其他数据中心进行数据同步。 PS：在Client注册的服务心跳监控检查由Client负责。 搭建环境 获得Docker镜像（bluersw/spring-cloud-consul-consumer 是服务消费者镜像里面运行的程序项目叫spring-cloud-consul-client，因为名字的起的不讲究导致了混乱，spring-cloud-consul-client不是Consul Client。）： docker pull consuldocker pull bluersw/spring-cloud-consul-consumer:ccdocker pull bluersw/spring-cloud-provider:ccdocker pull bluersw/spring-cloud-provider:ccdocker pull bluersw/spring-cloud-provider-second:cc 启动Consul Server(Windows版本的Docker运行命令时参数的IP地址要用”ip地址”,比如：-client=”0.0.0.0”)： docker run -i -t -p 8500:8500 –name=ConsulServer-C consul agent -server -ui -node=Server-C -bootstrap-expect=3 -client=0.0.0.0docker run -i -t -p 8501:8500 –name=ConsulServer-A consul agent -server -ui -node=Server-A -bootstrap-expect=3 -client=0.0.0.0 -join=172.17.0.2docker run -i -t -p 8502:8500 –name=ConsulServer-B consul agent -server -ui -node=Server-B -bootstrap-expect=3 -client=0.0.0.0 -join=172.17.0.2 启动spring-cloud-provider： docker run –name=spring-cloud-provider -d -p 9001:9001 bluersw/spring-cloud-provider:cc /opt/consul/./consul agent -data-dir=/opt/consul/data -config-dir=/opt/consul/config -node=privider-cc -join 172.17.0.3 在启动此Docker的同时运行Consul Client模式，并加入Consul Server A（加入那个Consul Server都可以）,TAG为CC的镜像文件里已经包含了Consul程序。 spring-cloud-provider的配置文件内容： spring.application.name=spring-cloud-provider-01server.port=9001spring.cloud.consul.host=127.0.0.1spring.cloud.consul.port=8500#注册到consul的服务名称spring.cloud.consul.discovery.serviceName=service-provider#以下两项如果不配置健康检查一定失败spring.cloud.consul.discovery.prefer-ip-address=truespring.cloud.consul.discovery.health-check-path=/actuator/health 配置中的注册服务地址已经改成了127.0.0.1，其他服务项目的配置文件都改成了在本机的Consul Client中注册。 启动服务： docker exec spring-cloud-provider /usr/local/java/bin/java -jar /opt/spring-cloud-provider-0.0.1-SNAPSHOT.jar service-provider服务在privider-cc节点被注册成功。 用同样的方法启动spring-cloud-provider-second和spring-cloud-consul-consumer。 docker run –name=spring-cloud-provider-second -d -p 9002:9002 bluersw/spring-cloud-provider-second:cc /opt/consul/./consul agent -data-dir=/opt/consul/data -config-dir=/opt/consul/config -node=provider-second-cc -join 172.17.0.4docker exec spring-cloud-provider-second /usr/local/java/bin/java -jar /opt/spring-cloud-provider-second-0.0.1-SNAPSHOT.jardocker run –name=spring-cloud-consul-consumer -d -p 9003:9003 bluersw/spring-cloud-consul-consumer:cc /opt/consul/./consul agent -data-dir=/opt/consul/data -config-dir=/opt/consul/config -node=consumer-cc -join 172.17.0.2docker exec spring-cloud-consul-consumer /usr/local/java/bin/java -jar /opt/spring-cloud-consul-client-0.0.1-SNAPSHOT.jar 模拟服务器故障 关闭Consul Server B： 因为service-provider在本机的Consul Client中注册，并Client可以利用LAN gossip协议找到可用的Server，所以关闭Consul Server B丝毫造成不了影响,如果Client或者服务本身挂掉了，那么Server端会将此节点或服务标记故障并不再使用，请求者就请求不到这个故障的节点了,同样的修复故障节点后所有服务和功能恢复如初。","categories":[{"name":"分布式","slug":"分布式","permalink":"http://blog.binvon.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://blog.binvon.com/tags/springcloud/"},{"name":"consul","slug":"consul","permalink":"http://blog.binvon.com/tags/consul/"}]},{"title":"编写Systemd服务文件","slug":"编写Systemd服务文件","date":"2020-03-04T18:11:22.000Z","updated":"2020-03-10T15:03:42.000Z","comments":true,"path":"2020/03/05/编写Systemd服务文件/","link":"","permalink":"http://blog.binvon.com/2020/03/05/%E7%BC%96%E5%86%99Systemd%E6%9C%8D%E5%8A%A1%E6%96%87%E4%BB%B6/","excerpt":"","text":"一种以 .service 结尾的单元（unit）配置文件，用于62616964757a686964616fe58685e5aeb931333363356634控制由 systemd 控制或监视的进程。简单说，用于后台以守护精灵（daemon）的形式运行程序。 编写 Systemd service 基本结构 Systemd 服务的内容主要分为三个部分，控制单元（unit）的定义、服务（service）的定义、以及安装部分。 和 SysV init 脚本的差异 过去，*nix 服务（守护精灵）都是用 SysV 启动脚本启动的。SysV 启动脚本就是 Bash 脚本，通常在 /etc/init.d 目录下，可以被一些标准参数如 start，stop，restart 等调用。启动该脚本通常意味着启动一个后台守护精灵（daemon）。shell 脚本常见的缺点就是，慢、可读性不强、太详细又很傲娇。虽然它们很灵活（毕竟那就是代码呀），但是有些事只用脚本做还是显得太困难了，比如安排并列执行、正确监视进程，或者配置详细执行环境。 SysV 启动脚本还有一个硬伤就是，臃肿，重复代码太多。因为上述的“标准参数”必须要靠各个脚本来实现，而且各个脚本之间的实现都差不多（根本就是从一个 skeleton 骨架来的）。而 Systemd 则进行了统一实现，也就是说在 Systemd service 中完全就不需要、也看不到这部分内容。这使得 Systemd 服务非常简明易读，例如 NetworkManager 这一重量级程序的服务，算上注释一共才有 19 行。而它相应的 SysV 启动脚本头 100 行连标准参数都没实现完。 Systemd 兼容 Sysv 启动脚本，这也是为什么这么久我们仍然需要一个 systemd-sysvinit 软件包的原因。但是根据以上理由，最好针对所有您安装的守护精灵都使用原生 Systemd 服务来启动。另外，Systemd 服务可无缝用于所有使用 Systemd 的发行版，意思是 Arch 下编写的脚本拿过来依然能够使用。 通常来说，上游应该在发布源代码的同时发布 Systemd 服务，但如果没发布，你可以对照本教学来为它们写一个并贡献给它们。 Systemd 语法 Systemd 语法和 .desktop 文件的语法比较像，也比较类似 Windows 下的 .ini 文件，因此无论对于打包者还是最终用户都是非常容易上手的。 主要格式请见下面的小例子，这里需要说明三点： Systemd 单元文件中的以 “#” 开头的行后面的内容会被认为是注释 Systemd 下的布尔值，1、yes、on、true 都是开启，0、no、off、false 都是关闭。注： 仅限于 Systemd 文件，比如： RemainOnExit=yes 并不适用于该文件中嵌入的 shell 语句，比如： ExecStartPre=/usr/bin/test “x${NETWORKMANAGER}” = xyes 这里的 yes 就不能替换。因为等号后面是一条嵌入的 shell 语句。 Systemd 下的时间单位默认是秒，所以要用毫秒（ms）分钟（m）等请显式说明。 一个小例子 NetworkManager 的 Systemd service： [Unit] Description=Network Manager After=syslog.target Wants=remote-fs.target network.target [Service] Type=dbus BusName=org.freedesktop.NetworkManager ExecStart=/usr/sbin/NetworkManager –no-daemon EnvironmentFile=/etc/sysconfig/network/config ExecStartPre=/usr/bin/test “x${NETWORKMANAGER}” = xyes # Suppress stderr to eliminate duplicated messages in syslog. NM calls openlog() # with LOG_PERROR when run in foreground. But systemd redirects stderr to # syslog by default, which results in logging each message twice. StandardError=null [Install] WantedBy=multi-user.target Also=NetworkManager-wait-online.service 以下我们以编写 He.net IPv6 单元文件为例。 定义控制单元 [Unit] 在 Systemd 中，所有引导过程中 Systemd 要控制的东西都是一个单元。Systemd 单元类型有： 系统服务 套接字（socket） 设备 挂载点 自动挂载点 SWAP 文件 分区 启动对象（startup target） 文件系统路径 定时器 简单说，Systemd 把 *nix 里那些分散开发因此宏观看变成一团杂碎的东西重新统一命名了。单元名就是你写的这个 .service 文件的名称。但不只有 .service 后缀的文件才可以是一个单元，单元还可以有 .target, .path 等后缀，具体可以去 /usr/lib/systemd/system 下了解。但那种后缀要么由 Systemd 上游开发者写好随 systemd 软件包分发，要么由我们的 Base:system 团队添加，一般用户是不太需要写其它后缀的控制单元的。 我们先要声明我们在定义控制单元： [Unit] 单元名称就不用写了，我们要写一条单元描述： [Unit] Description=Daemon to start He.net IPv6 下面我们要讲解一下 Systemd 是如何控制各个单元之间的关系的。它和 RPM 的 specfile 的依赖关系控制的语法非常相似（毕竟都是红帽一家的）： Requires: 这个单元启动了，那么它“需要”的单元也会被启动; 它“需要”的单元被停止了，它自己也活不了。但是请注意，这个设定并不能控制某单元与它“需要”的单元的启动顺序（启动顺序是另外控制的），即 Systemd 不是先启动 Requires 再启动本单元，而是在本单元被激活时，并行启动两者。于是会产生争分夺秒的问题，如果 Requires 先启动成功，那么皆大欢喜; 如果 Requires 启动得慢，那本单元就会失败（Systemd 没有自动重试）。所以为了系统的健壮性，不建议使用这个标记，而建议使用 Wants 标记。可以使用多个 Requires。 RequiresOverridable：跟 Requires 很像。但是如果这条服务是由用户手动启动的，那么 RequiresOverridable 后面的服务即使启动不成功也不报错。跟 Requires 比增加了一定容错性，但是你要确定你的服务是有等待功能的。另外，如果不由用户手动启动而是随系统开机启动，那么依然会有 Requires 面临的问题。 Requisite：强势版本的 Requires。要是这里需要的服务启动不成功，那本单元文件不管能不能检测等不能等待都立刻就会失败。 Wants：推荐使用。本单元启动了，它“想要”的单元也会被启动。但是启动不成功，对本单元没有影响。 Conflicts：一个单元的启动会停止与它“冲突”的单元，反之亦然。注意这里和后面的启动顺序是“正交”的： 两个相互冲突的单元被同时启动，要么两个都启动不了（两者都是第三个单元的 Requires），要么启动一个（有一个是第三个单元的 Requires，另一个不是），不是 Requires 的那个会被停止。要是两者都不是任何一个单元的 Requires，那么 Conflicts 别的那个单元优先启动，被 Conflicts 的后启动，要是互相写了，那么两个都启动不了。 OnFailure：很明显，如果本单元失败了，那么启动什么单元作为折衷。 好了，现在我们来想象一下，我们的单元（Ipv6 隧道）应该想要什么呢？很显然是一个连通着的网络。有一个 Systemd 默认提供的对象叫做 network-online.target（默认的 target 列表可见 systemd.special，必看，因为你大多数时候 Wants 的都是一个固定的系统状态而不是其它 systemd 服务），正正好好能够提供我们需要的环境。于是： [Unit] Description=Daemon to start He.net IPv6 Wants=network-online.target 下面我们需要定义一下服务启动顺序，不然连 / 目录所在的硬盘都没挂载就开始干活，上哪儿找程序去呀。Systemd 服务启动顺序主要使用以下两个标记定义的： Before/After：要是一个服务 Before 另一个服务，那么在并行启动时（Systemd 总是用进程 0 并行启动所有东西，然后通过这两个标记来二次等待排序），那另一个服务这时就会等这个服务先启动并返回状态，注意是先启动而不是启动成功，因为失败也是一种状态，一定要成功才启动另一个服务是通过依赖关系定义的。反之 After 亦然。 下面说下“关机”（可以是挂起，这时候有些服务是依然在跑的，比如网络唤醒）时候的顺序：如果两个服务都是要关掉的，Before 是先关自己，After 是先关别人，这很好理解; 但如果一个服务是要关，而另一个是要开的，那么不管 Before/After 写了什么，总是优先关闭而不是开始。也就是比如服务 A Before 服务 B，但是服务 B 是在关，而服务 A 是在 restart，那么服务 B 的顺序在服务 A 的前面。 好啦，我们的单元应该在什么的前后启动呢？它不需要一定在什么服务前面跑起来，这不像 ifup 和 dhcp，网络起不来获取 ip 肯定没用。我们只需要有网就可以了。“有网”在 Systemd 中也是由一个默认 target：network.target 提供的，于是我们的控制单元就定义好了： [Unit] Description=Daemon to start He.net IPv6 Wants=network-online.target After=network.target 定义服务本体 [service] 在定义完了 Systemd 用来识别服务的单元后，我们来定义服务本体，依然是声明： [Service] 然后是声明服务类型： [Service] Type= Systemd 支持的服务类型有以下几类： simple 默认，这是最简单的服务类型。意思就是说启动的程序就是主体程序，这个程序要是退出那么一切皆休。这在图形界面里非常好理解，我打开 Amarok，退出它就没有了。但是命令行的大部分程序都不会那么设计，因为命令行的一个最基本原则就是一个好的程序不能独占命令行窗口。所以输入命令，回车，接着马上返回给你提示符，但程序已经执行了。所以只有少数程序比如 python xxx.py 还使用这种方式。在这种类型下面，如果你的主程序是要响应其它程序的，那么你的通信频道应该在启动本服务前就设好（套接字等），因此这种类型的服务，Systemd 运行它后会立刻就运行下面的服务（需要它的服务），这时没有套接字后面的服务会失败，写 After 也没用，因为 simple 类型不存在主进程退出的情况也就不存在有返回状态的情况，所以它一旦启动就认为是成功的，除非没起来。 forking 标准 Unix Daemon 使用的启动方式。启动程序后会调用 fork() 函数，把必要的通信频道都设置好之后父进程退出，留下守护精灵的子进程。你要是使用的这种方式，最好也指定下 PIDFILE=，不要让 Systemd 去猜，非要猜也可以，把 GuessMainPID 设为 yes。 判断是 forking 还是 simple 类型非常简单，命令行里运行下你的程序，持续占用命令行要按 Ctrl + C 才可以的，就不会是 forking 类型。 创建 PIDFILE 是你为它写服务的程序的任务而不是 Systemd 的功能，甚至也不是 Sysvinit 脚本的功能。参考 startproc创建pid file的问题了解进一步的知识。因此如果你的程序确实是 forking 类型，但就是没实现创建 PIDFILE 的功能，那么建议使用 ExecStartPost= 结合 shell 命令来手动抓取进程编号并写到 /var/run/xxx.pid。 oneshot 顾名思义，打一枪换一个地方。所以这种服务类型就是启动，完成，没进程了。常见比如你设置网络，ifup eth0 up，就是一次性的，不存在 ifup 的子进程（forking 那样），也不存在主进程（simple 那样），它运行完成后便了无痕迹。因为这类服务运行完就没进程了，我们经常会需要 RemainAfterExit=yes。后面配置的意思是说，即使没进程了，我们也要 Systemd 认为该服务是存在并成功了的。所以如果你有一个这样的服务，服务启动后，你再去 ifup eth0 up，这时你再看服务，依然显示是 running 的。因为只要在执行那条一次性命令的时候没出错，那么它就永远认为它是成功并一直存在的，直到你关闭服务。 dbus 这个程序启动时需要获取一块 DBus 空间，所以需要和 BusName= 一起用。只有它成功获得了 DBus 空间，依赖它的程序才会被启动。 一般人也就能用到上面四个，还有两种少见的类型： notify 这个程序在启动完成后会通过 sd_notify 发送一个通知消息。所以还需要配合 NotifyAccess 来让 Systemd 接收消息，后者有三个级别：none，所有消息都忽略掉; main，只接受我们程序的主进程发过去的消息; all，我们程序的所有进程发过去的消息都算。NotifyAccess 要是不写的话默认是 main。 idle 这个程序要等它里面调度的全部其它东西都跑完才会跑它自己。比如你 ExecStart 的是个 shell 脚本，里面可能跑了一些别的东西，如果不这样的话，那很可能别的东西的控制台输出里会多一个“启动成功”这样的 Systemd 消息。 由于 He.net 的 IPv6 是用 iproute2 的 ip 命令来弄的，所以是一个 oneshot 一次性服务。 [Service] Type=oneshot RemainAfterExit=yes 接下来要设置 ExecStart, ExecStop。如果程序支持的话，你还可以去设置 ExecReload，Restart 等。注意，这里设置的是它们 Reload/Restart 的方式，但并不代表没有它们 Systemd 就不能完成比如 systemctl restart xxx.service 这样的任务，程序有支持自然最好，程序不支持那就先 stop 再 start 咯。同样有特殊要求的时候你也可以去设置比如 ExecStartPre/ExecStartPost,RestartSec,TimeoutSec 等其它东西，参考链接里都有使用方法。 这里要特殊讲一下 ExecStart： 如果你服务的类型不是 oneshot，那么它只可以接受一个命令，参数不限，比如你先 ip tunnel create 再 ip tunnel0 up，那是两个 ip 命令，如果你不是 oneshot 类型这样是不行的。 如果有多条命令（oneshot 类型），命令之间以分号 ; 分隔，跨行可用反斜杠 \\。 除非你的服务类型是 forking，否则你在这里输入的命令都会被认为是主进程，不管它是不是。 于是我们的 [Service] 就写好了： [Service] Type=oneshot RemainAfterExit=yes ExecStart=/usr/sbin/ip tunnel add he-ipv6 mode sit remote 66.220.18.42 local 108.170.7.158 ttl 255 ; \\ /usr/sbin/ip link set he-ipv6 up ; \\ /usr/sbin/ip addr add 2001:470:c:1184::2/64 dev he-ipv6 ; \\ /usr/sbin/ip route add ::/0 dev he-ipv6 ; \\ /usr/sbin/ip -6 addr ExecStop=/usr/sbin/ip route delete ::/0 dev he-ipv6 ; \\ /usr/sbin/ip -6 addr del 2001:470:c:1184::2/64 dev he-ipv6 ; \\ /usr/sbin/ip link set he-ipv6 down ; \\ /usr/sbin/ip tunnel del he-ipv6 安装服务 [install] 这可能有点绕，我服务文件都弄好了，放到 /etc/systemd/system（供系统管理员和用户使用），/usr/lib/systemd/system（供发行版打包者使用）了，不就是安装好了嘛。 这里说的是一种内部状态，默认你放对位置它显示的是 disabled，unloaded，所以我们要在 Systemd 内部对它进行一下 load，没人要的东西是不需要安装的（我们不收渣渣），所以我们要告诉 Systemd 它是有人要的，被谁要。一般都是被 [Install] WantedBy=multi-user.target 要（multi-user.target 表示多用户系统好了，简单理解就是你可以登入了）。这样在 multi-user.target 启用时，我们的服务也就会被启用了。 [Install] 部分下除了 WantedBy 还有两种属性，分别是： Alias= 给你自己的别名，这样 systemctl command xxx.service 的时候就可以不输入完整的单元名称。比如你给 NetworkManager 一个别名叫 Alias=nm，那你就可以 systemctl status nm.service 查看实际是 NetworkManager.service 的服务了。 Also= 安装本服务的时候还要安装别的什么服务。比如我们的 He.net 脚本按理应该需要一个 iproute2.service 作为 also，但是 iproute2 实际上不需要 systemd 控制，所以就没写。它和 [Unit] 定义里面的依赖关系相比，它管理的不是运行时依赖，而是安装时。安装好了之后启动谁先谁后，谁依赖谁，和 Also= 都没有关系。","categories":[{"name":"服务器","slug":"服务器","permalink":"http://blog.binvon.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://blog.binvon.com/tags/linux/"}]},{"title":"使用goolge cloud建设ssr","slug":"使用goolge-cloud建设ssr","date":"2019-12-29T08:40:12.000Z","updated":"2021-10-07T03:38:00.994Z","comments":true,"path":"2019/12/29/使用goolge-cloud建设ssr/","link":"","permalink":"http://blog.binvon.com/2019/12/29/%E4%BD%BF%E7%94%A8goolge-cloud%E5%BB%BA%E8%AE%BEssr/","excerpt":"","text":"yum -y install wget wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh chmod +x shadowsocksR.sh ./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log ———————————————————代码分割线————输入每行回车设置密码13231端口236","categories":[{"name":"vpn","slug":"vpn","permalink":"http://blog.binvon.com/categories/vpn/"}],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://blog.binvon.com/tags/shadowsocks/"}]},{"title":"使用MyBatis编写Dao的两种语法","slug":"使用MyBatis编写Dao的两种语法","date":"2019-09-04T18:11:22.000Z","updated":"2019-09-10T15:03:42.000Z","comments":true,"path":"2019/09/05/使用MyBatis编写Dao的两种语法/","link":"","permalink":"http://blog.binvon.com/2019/09/05/%E4%BD%BF%E7%94%A8MyBatis%E7%BC%96%E5%86%99Dao%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AF%AD%E6%B3%95/","excerpt":"","text":"在MyBatis中，我们有两种Dao的写法，一种叫传统Dao写法，一种叫Mapper代理接口。下面看看如何实现。 1 传统Dao写法 1.1 编写CustomerDao接口 1234567891011121314151617181920212223242526272829303132333435/** * Dao接口 */public interface CustomerDao &#123; /** * 查询所有用户 */ public List&lt;Customer&gt; findAll(); /** * 添加 */ public void save(Customer customer); /** * 修改 */ public void update(Customer customer); /** * 查询一个 */ public Customer findById(Integer id); /** * 条件查询 */ public List&lt;Customer&gt; findByName(String name); /** * 删除 */ public void delete(Integer id);&#125; 1.2 编写CustomerDao实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * Dao实现类 */public class CustomerDaoImpl implements CustomerDao&#123; @Override public List&lt;Customer&gt; findAll() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSession(); return sqlSession.selectList(&quot;com.yiidian.dao.CustomerDao.findAll&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally&#123; sqlSession.close(); &#125; return null; &#125; @Override public void save(Customer customer) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSession(); sqlSession.insert(&quot;com.yiidian.dao.CustomerDao.save&quot;, customer); sqlSession.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125; finally&#123; sqlSession.close(); &#125; &#125; @Override public void update(Customer customer) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSession(); sqlSession.update(&quot;com.yiidian.dao.CustomerDao.update&quot;, customer); sqlSession.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125; finally&#123; sqlSession.close(); &#125; &#125; @Override public Customer findById(Integer id) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSession(); return sqlSession.selectOne(&quot;com.yiidian.dao.CustomerDao.findById&quot;,id); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally&#123; sqlSession.close(); &#125; return null; &#125; @Override public List&lt;Customer&gt; findByName(String name) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSession(); return sqlSession.selectList(&quot;com.yiidian.dao.CustomerDao.findByName&quot;,name); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally&#123; sqlSession.close(); &#125; return null; &#125; @Override public void delete(Integer id) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSession(); sqlSession.delete(&quot;com.yiidian.dao.CustomerDao.delete&quot;, id); sqlSession.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125; finally&#123; sqlSession.close(); &#125; &#125;&#125; 传统方式的重点在于Dao实现类，在Dao实现类中，手动调用SqlSession提供的方法直接执行映射文件的SQL语句。 1.3 编写CustomerDao.xml映射 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace: 用于指定该映射文件需要映射的Dao接口--&gt;&lt;mapper namespace=&quot;com.yiidian.dao.CustomerDao&quot;&gt; &lt;!--查询所有--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.yiidian.domain.Customer&quot;&gt; select * from t_customer &lt;/select&gt; &lt;!--1.添加方法--&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;com.yiidian.domain.Customer&quot;&gt; INSERT INTO t_customer(NAME,gender,telephone) VALUES(#&#123;name&#125;,#&#123;gender&#125;,#&#123;telephone&#125;) &lt;/insert&gt; &lt;!--2.修改方法--&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.yiidian.domain.Customer&quot;&gt; UPDATE t_customer SET NAME = #&#123;name&#125;, gender = #&#123;gender&#125;, telephone = #&#123;telephone&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; &lt;!--查询一个--&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;integer&quot; resultType=&quot;com.yiidian.domain.Customer&quot;&gt; select * from t_customer where id = #&#123;id&#125; &lt;/select&gt; &lt;!--条件查询--&gt; &lt;select id=&quot;findByName&quot; parameterType=&quot;string&quot; resultType=&quot;com.yiidian.domain.Customer&quot;&gt; select * from t_customer where name like #&#123;name&#125; &lt;/select&gt; &lt;!--删除--&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;integer&quot;&gt; delete from t_customer where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 1.4 编写测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** * MyBatis测试类 - 传统Dao写法 */public class TestCustomerDao &#123; /** * 添加 */ @Test public void testSave()&#123; //1.获取SqlSession对象 SqlSession session = MyBatisUtils.getSession(); //2.创建传统Dao实现类对象 CustomerDao customerDao = new CustomerDaoImpl(); //3.调用save方法 Customer customer = new Customer(); customer.setName(&quot;小苍&quot;); customer.setGender(&quot;女&quot;); customer.setTelephone(&quot;15755556666&quot;); customerDao.save(customer); //4.关闭连接 session.close(); &#125; /** * 修改 */ @Test public void testUpdate()&#123; //1.获取SqlSession对象 SqlSession session = MyBatisUtils.getSession(); //2.创建传统Dao实现类对象 CustomerDao customerDao = new CustomerDaoImpl(); //3.调用update方法 Customer customer = new Customer(); customer.setId(5); customer.setName(&quot;小泽&quot;); customer.setGender(&quot;女&quot;); customer.setTelephone(&quot;15755556666&quot;); customerDao.update(customer); session.commit(); //4.关闭连接 session.close(); &#125; /** * 查询所有 */ @Test public void testFindAll()&#123; //1.获取SqlSession对象 SqlSession session = MyBatisUtils.getSession(); //2.创建传统Dao实现类对象 CustomerDao customerDao = new CustomerDaoImpl(); //3.调用findAll方法 List&lt;Customer&gt; list = customerDao.findAll(); for(Customer cust:list)&#123; System.out.println(cust); &#125; //4.关闭连接 session.close(); &#125; /** * 查询一个 */ @Test public void testFindById()&#123; //1.获取SqlSession对象 SqlSession session = MyBatisUtils.getSession(); //2.创建传统Dao实现类对象 CustomerDao customerDao = new CustomerDaoImpl(); //3.调用findById方法 Customer customer = customerDao.findById(3); System.out.println(customer); //4.关闭连接 session.close(); &#125; /** * 条件查询 */ @Test public void testFindByName()&#123; //1.获取SqlSession对象 SqlSession session = MyBatisUtils.getSession(); //2.创建传统Dao实现类对象 CustomerDao customerDao = new CustomerDaoImpl(); //3.调用findByName方法 List&lt;Customer&gt; list = customerDao.findByName(&quot;%小%&quot;); for(Customer cust:list)&#123; System.out.println(cust); &#125; //4.关闭连接 session.close(); &#125; /** * 删除 */ @Test public void testDelete()&#123; //1.获取SqlSession对象 SqlSession session = MyBatisUtils.getSession(); //2.创建传统Dao实现类对象 CustomerDao customerDao = new CustomerDaoImpl(); //3.调用findByName方法 customerDao.delete(5); // 提交事务 session.commit(); //4.关闭连接 session.close(); &#125;&#125; 2 Mapper代理接口 2.1 编写CustomerDao接口 1234567891011121314151617181920212223242526272829303132333435/** * Dao接口 */public interface CustomerDao &#123; /** * 查询所有用户 */ public List&lt;Customer&gt; findAll(); /** * 添加 */ public void save(Customer customer); /** * 修改 */ public void update(Customer customer); /** * 查询一个 */ public Customer findById(Integer id); /** * 条件查询 */ public List&lt;Customer&gt; findByName(String name); /** * 删除 */ public void delete(Integer id);&#125; 2.2 编写CustomerDao.xml映射 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace: 用于指定该映射文件需要映射的Dao接口--&gt;&lt;mapper namespace=&quot;com.yiidian.dao.CustomerDao&quot;&gt; &lt;!--查询所有--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.yiidian.domain.Customer&quot;&gt; select * from t_customer &lt;/select&gt; &lt;!--1.添加方法--&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;com.yiidian.domain.Customer&quot;&gt; INSERT INTO t_customer(NAME,gender,telephone) VALUES(#&#123;name&#125;,#&#123;gender&#125;,#&#123;telephone&#125;) &lt;/insert&gt; &lt;!--2.修改方法--&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.yiidian.domain.Customer&quot;&gt; UPDATE t_customer SET NAME = #&#123;name&#125;, gender = #&#123;gender&#125;, telephone = #&#123;telephone&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; &lt;!--查询一个--&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;integer&quot; resultType=&quot;com.yiidian.domain.Customer&quot;&gt; select * from t_customer where id = #&#123;id&#125; &lt;/select&gt; &lt;!--条件查询--&gt; &lt;select id=&quot;findByName&quot; parameterType=&quot;string&quot; resultType=&quot;com.yiidian.domain.Customer&quot;&gt; select * from t_customer where name like #&#123;name&#125; &lt;/select&gt; &lt;!--删除--&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;integer&quot;&gt; delete from t_customer where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 2.3 编写测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** * MyBatis测试类 - Mapper代理接口 */public class TestCustomerDao2 &#123; /** * 添加 */ @Test public void testSave()&#123; //1.获取SqlSession对象 SqlSession session = MyBatisUtils.getSession(); //2.生成Dao代理对象 CustomerDao customerDao = session.getMapper(CustomerDao.class); //3.调用save方法 Customer customer = new Customer(); customer.setName(&quot;小苍&quot;); customer.setGender(&quot;女&quot;); customer.setTelephone(&quot;15755556666&quot;); customerDao.save(customer); //4.关闭连接 session.close(); &#125; /** * 修改 */ @Test public void testUpdate()&#123; //1.获取SqlSession对象 SqlSession session = MyBatisUtils.getSession(); //2.生成Dao代理对象 CustomerDao customerDao = session.getMapper(CustomerDao.class); //3.调用update方法 Customer customer = new Customer(); customer.setId(5); customer.setName(&quot;小泽&quot;); customer.setGender(&quot;女&quot;); customer.setTelephone(&quot;15755556666&quot;); customerDao.update(customer); session.commit(); //4.关闭连接 session.close(); &#125; /** * 查询所有 */ @Test public void testFindAll()&#123; //1.获取SqlSession对象 SqlSession session = MyBatisUtils.getSession(); //2.生成Dao代理对象 CustomerDao customerDao = session.getMapper(CustomerDao.class); //3.调用findAll方法 List&lt;Customer&gt; list = customerDao.findAll(); for(Customer cust:list)&#123; System.out.println(cust); &#125; //4.关闭连接 session.close(); &#125; /** * 查询一个 */ @Test public void testFindById()&#123; //1.获取SqlSession对象 SqlSession session = MyBatisUtils.getSession(); //2.生成Dao代理对象 CustomerDao customerDao = session.getMapper(CustomerDao.class); //3.调用findById方法 Customer customer = customerDao.findById(5); System.out.println(customer); //4.关闭连接 session.close(); &#125; /** * 条件查询 */ @Test public void testFindByName()&#123; //1.获取SqlSession对象 SqlSession session = MyBatisUtils.getSession(); //2.生成Dao代理对象 CustomerDao customerDao = session.getMapper(CustomerDao.class); //3.调用findByName方法 List&lt;Customer&gt; list = customerDao.findByName(&quot;%小%&quot;); for(Customer cust:list)&#123; System.out.println(cust); &#125; //4.关闭连接 session.close(); &#125; /** * 删除 */ @Test public void testDelete()&#123; //1.获取SqlSession对象 SqlSession session = MyBatisUtils.getSession(); //2.生成Dao代理对象 CustomerDao customerDao = session.getMapper(CustomerDao.class); //3.调用findByName方法 customerDao.delete(5); // 提交事务 session.commit(); //4.关闭连接 session.close(); &#125;&#125;","categories":[{"name":"持久层","slug":"持久层","permalink":"http://blog.binvon.com/categories/%E6%8C%81%E4%B9%85%E5%B1%82/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://blog.binvon.com/tags/mybatis/"}]},{"title":"java中websocket的简单使用","slug":"java中websocket的简单使用","date":"2019-04-05T06:11:22.000Z","updated":"2019-04-10T10:03:42.000Z","comments":true,"path":"2019/04/05/java中websocket的简单使用/","link":"","permalink":"http://blog.binvon.com/2019/04/05/java%E4%B8%ADwebsocket%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1.上图 2.引入jar包 &lt;**dependency**&gt; &lt;**groupId**&gt;javax&lt;/**groupId**&gt; &lt;**artifactId**&gt;javaee-api&lt;/**artifactId**&gt; &lt;**version**&gt;7.0&lt;/**version**&gt; &lt;**scope**&gt;provided&lt;/**scope**&gt; &lt;/**dependency**&gt; 3.java后台代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.fb.controller.web;import java.io.IOException;import java.util.concurrent.CopyOnWriteArraySet;import javax.websocket.*;import javax.websocket.server.ServerEndpoint;/** * @ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端, * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端 */@ServerEndpoint(&quot;/websocket&quot;)public class MyWebSocket &#123; //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。 private static int onlineCount = 0; //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。若要实现服务端与单一客户端通信的话，可以使用Map来存放，其中Key可以为用户标识 private static CopyOnWriteArraySet&lt;MyWebSocket&gt; webSocketSet = new CopyOnWriteArraySet&lt;MyWebSocket&gt;(); //与某个客户端的连接会话，需要通过它来给客户端发送数据 private Session session; /** * 连接建立成功调用的方法 * @param session 可选的参数。session为与某个客户端的连接会话，需要通过它来给客户端发送数据 */ @OnOpen public void onOpen(Session session)&#123; this.session = session; webSocketSet.add(this); //加入set中 addOnlineCount(); //在线数加1 System.out.println(&quot;有新连接加入！当前在线人数为&quot; + getOnlineCount()); &#125; /** * 连接关闭调用的方法 */ @OnClose public void onClose()&#123; webSocketSet.remove(this); //从set中删除 subOnlineCount(); //在线数减1 System.out.println(&quot;有一连接关闭！当前在线人数为&quot; + getOnlineCount()); &#125; /** * 收到客户端消息后调用的方法 * @param message 客户端发送过来的消息 * @param session 可选的参数 */ @OnMessage public void onMessage(String message, Session session) &#123; System.out.println(&quot;来自客户端的消息:&quot; + message); //群发消息 for(MyWebSocket item: webSocketSet)&#123; try &#123; item.sendMessage(message); &#125; catch (IOException e) &#123; e.printStackTrace(); continue; &#125; &#125; &#125; /** * 发生错误时调用 * @param session * @param error */ @OnError public void onError(Session session, Throwable error)&#123; System.out.println(&quot;发生错误&quot;); error.printStackTrace(); &#125; /** * 这个方法与上面几个方法不一样。没有用注解，是根据自己需要添加的方法。 * @param message * @throws IOException */ public void sendMessage(String message) throws IOException&#123; this.session.getBasicRemote().sendText(message); //this.session.getAsyncRemote().sendText(message); &#125; public static synchronized int getOnlineCount() &#123; return onlineCount; &#125; public static synchronized void addOnlineCount() &#123; MyWebSocket.onlineCount++; &#125; public static synchronized void subOnlineCount() &#123; MyWebSocket.onlineCount--; &#125;&#125; 4.前台代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;html&gt;&lt;head&gt; &lt;title&gt;websocket&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Welcome&lt;br/&gt;&lt;div id=&quot;message&quot; style=&quot;color: blue&quot;&gt;[状态]&lt;/div&gt;&lt;br/&gt;昵称：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;br/&gt;内容：&lt;input id=&quot;text&quot; type=&quot;text&quot;/&gt;&lt;br/&gt;&lt;button οnclick=&quot;send()&quot;&gt;发送&lt;/button&gt;&lt;button οnclick=&quot;closeWebSocket()&quot;&gt;关闭&lt;/button&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var websocket = null; //判断当前浏览器是否支持WebSocket if (&#x27;WebSocket&#x27; in window) &#123; websocket = new WebSocket(&quot;ws://localhost:9090/wanglh/websocket&quot;); &#125; else &#123; alert(&#x27;当前浏览器 Not support websocket&#x27;) &#125; //连接发生错误的回调方法 websocket.onerror = function () &#123; setMessageInnerHTML(&quot;WebSocket连接发生错误&quot;); &#125;; //连接成功建立的回调方法 websocket.onopen = function () &#123; setMessageInnerHTML(&quot;WebSocket连接成功&quot;); &#125; //接收到消息的回调方法 websocket.onmessage = function (event) &#123; setMessageInnerHTML(event.data); &#125; //连接关闭的回调方法 websocket.onclose = function () &#123; setMessageInnerHTML(&quot;WebSocket连接关闭&quot;); &#125; //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 window.onbeforeunload = function () &#123; closeWebSocket(); &#125; //将消息显示在网页上 function setMessageInnerHTML(innerHTML) &#123; document.getElementById(&#x27;message&#x27;).innerHTML += innerHTML + &#x27;&lt;br/&gt;&#x27;; &#125; //关闭WebSocket连接 function closeWebSocket() &#123; websocket.close(); &#125; //发送消息 function send() &#123; var username=document.getElementById(&#x27;username&#x27;).value; var message = document.getElementById(&#x27;text&#x27;).value; var msg=&quot;[&quot;+username+&quot;]:&quot;+message; websocket.send(msg); &#125;&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/categories/java/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"http://blog.binvon.com/tags/websocket/"}]},{"title":"redis存储对象的三种方式","slug":"redis存储对象的三种方式","date":"2019-04-05T04:11:22.000Z","updated":"2019-04-10T15:03:42.000Z","comments":true,"path":"2019/04/05/redis存储对象的三种方式/","link":"","permalink":"http://blog.binvon.com/2019/04/05/redis%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"方式一：序列化操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class SerializeUtil &#123; /* * 序列化 * */ public static byte[] serizlize(Object object)&#123; ObjectOutputStream oos = null; ByteArrayOutputStream baos = null; try &#123; baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(object); byte[] bytes = baos.toByteArray(); return bytes; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(baos != null)&#123; baos.close(); &#125; if (oos != null) &#123; oos.close(); &#125; &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; return null; &#125; /* * 反序列化 * */ public static Object deserialize(byte[] bytes)&#123; ByteArrayInputStream bais = null; ObjectInputStream ois = null; try&#123; bais = new ByteArrayInputStream(bytes); ois = new ObjectInputStream(bais); return ois.readObject(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; return null; &#125;&#125; 获取jedis实例 123456789101112131415161718192021222324252627282930313233343536373839404142public class RedisConnection &#123; private static String HOST = &quot;127.0.0.1&quot;; private static int PORT = 6379; private static int MAX_ACTIVE = 1024; private static int MAX_IDLE = 200; private static int MAX_WAIT = 10000; private static JedisPool jedisPool = null; /* * 初始化redis连接池 * */ private static void initPool()&#123; try &#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(MAX_ACTIVE);//最大连接数 config.setMaxIdle(MAX_IDLE);//最大空闲连接数 config.setMaxWaitMillis(MAX_WAIT);//获取可用连接的最大等待时间 jedisPool = new JedisPool(config, HOST, PORT); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /* * 获取jedis实例 * */ public synchronized static Jedis getJedis() &#123; try &#123; if(jedisPool == null)&#123; initPool(); &#125; Jedis jedis = jedisPool.getResource(); jedis.auth(&quot;redis&quot;);//密码 return jedis; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; redis操作 123456789101112131415161718192021222324public class RedisOps &#123; public static void set(String key,String value)&#123; Jedis jedis = RedisConnection.getJedis(); jedis.set(key, value); jedis.close(); &#125; public static String get(String key)&#123; Jedis jedis = RedisConnection.getJedis(); String value = jedis.get(key); jedis.close(); return value; &#125; public static void setObject(String key,Object object)&#123; Jedis jedis = RedisConnection.getJedis(); jedis.set(key.getBytes(), SerializeUtil.serizlize(object)); jedis.close(); &#125; public static Object getObject(String key)&#123; Jedis jedis = RedisConnection.getJedis(); byte[] bytes = jedis.get(key.getBytes()); jedis.close(); return SerializeUtil.deserialize(bytes); &#125;&#125; 实体类 12345678910111213public class User implements Serializable&#123; private static final long serialVersionUID = -3210884885630038713L; private int id; private String name; public User()&#123; &#125; public User(int id,String name)&#123; this.id = id; this.name = name; &#125; //setter和getter方法&#125; 测试用例 1234567891011121314151617public class RedisTest &#123; @Test public void testString()&#123; RedisOps.set(&quot;user:1&quot;, &quot;sisu&quot;); String user = RedisOps.get(&quot;user:1&quot;); Assert.assertEquals(&quot;sisu&quot;, user); &#125; @Test public void testObject()&#123; RedisOps.setObject(&quot;user:2&quot;,new User(2,&quot;lumia&quot;)); User user = (User)RedisOps.getObject(&quot;user:2&quot;); Assert.assertEquals(&quot;lumia&quot;, user.getName()); &#125;&#125; 测试: 12345678910111213public class RedisOps &#123; public static void setJsonString(String key,Object object)&#123; Jedis jedis = RedisConnection.getJedis(); jedis.set(key, JSON.toJSONString(object)); jedis.close(); &#125; public static Object getJsonObject(String key,Class clazz)&#123; Jedis jedis = RedisConnection.getJedis(); String value = jedis.get(key); jedis.close(); return JSON.parseObject(value,clazz); &#125;&#125; 测试： 123456@Testpublic void testObject2()&#123; RedisOps.setJsonString(&quot;user:3&quot;, new User(3,&quot;xiaoming&quot;)); User user = (User)RedisOps.getJsonObject(&quot;user:3&quot;,User.class); Assert.assertEquals(&quot;xiaoming&quot;, user.getName()); &#125; 方式三：使用Hash数据类型 12345678910//存Jedis jedis = RedisConnection.getJedis(); jedis.hSet(&quot;user:3&quot;,&quot;id&quot;,&quot;3&quot;); jedis.hSet(&quot;user:3&quot;,&quot;name&quot;,&quot;xiaoming&quot;); jedis.close();//取 Jedis jedis = RedisConnection.getJedis(); String id = jedis.hGet(&quot;user:3&quot;,&quot;id&quot;); String name = jedis.hGet(&quot;user:3&quot;,&quot;name&quot;); jedis.close();","categories":[{"name":"缓存","slug":"缓存","permalink":"http://blog.binvon.com/categories/%E7%BC%93%E5%AD%98/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://blog.binvon.com/tags/redis/"}]},{"title":"Java多线程的4种实现方式","slug":"Java多线程的4种实现方式","date":"2019-03-04T18:11:22.000Z","updated":"2019-03-10T15:03:42.000Z","comments":true,"path":"2019/03/05/Java多线程的4种实现方式/","link":"","permalink":"http://blog.binvon.com/2019/03/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%844%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","excerpt":"","text":"Java多线程的4种实现方式 1：继承Thread并重写run方法，并调用start方法 1234567891011121314151617181920212223242526/** * Java实现多线程的方式1 * 继承Thread类，重写run方法 */class MyThread extends Thread &#123; @Override public void run() &#123; //此处为thread执行的任务内容 System.out.println(Thread.currentThread().getName()); &#125;&#125;public class Demo03 &#123; public static void main(String[] args) &#123; for(int i=0;i&lt;2;i++) &#123; Thread t = new MyThread(); //输出： //Thread-0 Thread-1 t.start(); &#125; &#125;&#125; 2：实现Runnable接口，并用其初始化Thread，然后创建Thread实例，并调用start方法 1234567891011121314151617181920212223242526/** * Java实现多线程的方式2 * 实现Runnable接口 */class MyThread implements Runnable &#123; @Override public void run() &#123; //此处为thread执行的任务内容 System.out.println(Thread.currentThread().getName()); &#125;&#125;public class Demo03 &#123; public static void main(String[] args) &#123; for(int i=0;i&lt;2;i++) &#123; Thread t = new Thread(new MyThread()); //输出： //Thread-0 Thread-1 t.start(); &#125; &#125;&#125; 3：实现Callable接口，并用其初始化Thread，然后创建Thread实例，并调用start方法 12345678910111213141516171819202122232425262728/** * Java实现多线程的方式3 * 实现Callable接口 */class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(Thread.currentThread().getName()); return null; &#125;&#125;public class Demo03 &#123; public static void main(String[] args) &#123; for(int i=0;i&lt;2;i++) &#123; //创建MyThread实例 Callable&lt;Integer&gt; c = new MyThread(); //获取FutureTask FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(c); //使用FutureTask初始化Thread Thread t = new Thread(ft); //输出： //Thread-0 Thread-1 t.start(); &#125; &#125;&#125; 4：使用线程池创建 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Java实现多线程的方式4 * 线程池 */class MyThread implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;class MyThread2 implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(Thread.currentThread().getName()); return 0; &#125; &#125;public class Demo03 &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(5); for(int i=0;i&lt;2;i++) &#123; executorService.execute(new MyThread()); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(new MyThread2()); //输出// pool-1-thread-1// pool-1-thread-2// pool-1-thread-3// pool-1-thread-4 executorService.submit(ft); &#125; executorService.shutdown(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/categories/java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.binvon.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"生成分布式ID算法.","slug":"生成分布式ID算法","date":"2018-08-04T18:11:22.000Z","updated":"2018-08-10T15:03:42.000Z","comments":true,"path":"2018/08/05/生成分布式ID算法/","link":"","permalink":"http://blog.binvon.com/2018/08/05/%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8FID%E7%AE%97%E6%B3%95/","excerpt":"","text":"一、分布式ID 1. 为什么需要分布式全局唯一ID？ 在复杂的分布式系统中，往往需要对大量的数据和消息进行唯一标识。如在美团点评的金融、支付、餐饮、酒店等产品的系统中数据日渐增长，对数据分库分表后需要有一个唯一ID来标识某一条数据或消息，此时一个能够生成全局唯一ID的系统是非常必要的。 2. 那么分布式ID生成需要满足哪些条件 全局唯一：分布式系统下必须要保证ID是全局唯一的，这是最基本的要求； 高性能：高可用低延时，ID生成响应要快，否则反倒会成为业务瓶颈； 高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用； 好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单； 趋势递增：由于多数公司使用的是MySQL InnoDB作为存储引擎，所以ID最好趋势递增。 二、一般通用方案 1. UUID String uuid = UUID.randomUUID().toString().replaceAll(“-“,””); UUID的标准形式：包含32个16进制数字，以连字号分为五段，形式为8-4-4-12的36个字符； 优点：代码简单，性能非常高（本地生成，没有网络消耗），保证唯一（重复概率极低可以忽略）； 缺点：生成的ID是无序的字符串，无法保证趋势递增，且没有一定的业务含义；还有就是长度过长入且无序，会严重消耗MySQL数据库性能。 为什么无序的UUID会导致入库性能变差呢？ 作为主键过长，MySQL官方有明确的建议主键尽量越短越好，36个字符长度的UUID不符合要求； 字符串且无序，MySQL InnoDB引擎的索引底层数据结构是B+树，每一次新的UUID插入表，都会对主键底层的B+树索引进行很大的修改，插入完全无序，不但会导致一些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能，还会增加读取磁盘的次数。 2. 数据库自增主键 单点模式自增ID 在分布式里，数据库的自增ID机制的主要原理是：数据库自增ID和MySql数据库的replace into实现的。 replace into 跟 insert 功能类似，不同点在于：replace into首先尝试插入数据列表中，如果发现表中已经有此行数据（根据主键或唯一索引）判断是否存在，若有则先删除再插入，否则直接插入新数据。REPLACE INTO的含义是插入一条记录，如果表中唯一索引的值遇到冲突，则替换老数据。 CREATE TABLE t_test ( id bigint(20) unsigned not null auto_increment primary key, stub char(1) not null default ‘’, unique key stub (stub) ) select * from t_test; replace into t_test (stub) values(‘a’); select last_insert_id(); 当我们需要一个ID时，向表中插入一条记录返回主键ID即可。此种方式优点：实现简单，ID单调自增，数值类型查询速度快；缺点：1）强依赖DB，存在单点问题，一旦数据库宕机，整个业务不可用；2）单点数据库压力大，无法扛住高并发场景；3）信息安全问题，比如暴露订单量等。 集群式自增ID 对上面单点模式做优化，改成集群模式自增ID，也就是多个MySQL实例各自生成自增ID。要设置起始值和自增步长，保证生成ID不会重复。 优点：解决了ID生成的单点问题，同时平衡了负载； 缺点：系统后续水平扩容比较困难，增加机器可能要修改步长，起始值也不容易设置。数据库压力还是很大，每次获取ID都得读写一次数据库，非常影响性能，依旧无法满足高并发场景。 3. 基于Redis生成全局ID策略 因为Redis是单线程的天生保证原子性， 利用Redis的incr命令实现ID的原子性自增。 127.0.0.1:6379&gt; set seq_id 1 // 初始化自增ID为1 OK 127.0.0.1:6379&gt; incr seq_id // 增加1，并返回递增后的数值 (integer) 2 集群分布式，可以使用Redis集群来获取更高的吞吐量，注意：在Redis集群情况下，同样和MySql一样需要设置不同的增长步长，同时key一定要设置有效期。 假如一个集群中有5台Redis，可以初始化每台Redis的值分别是1，2，3，4，5 然后步长都是5，每个redis生成的ID为： ​ A：1、6、11、16、21 B：2、7、12、17、22 C：3、8、13、18、23 D：4、9、14、19、24 E：5、10、15、20、25 优点：效率高，不依赖数据库，可以扛住高并发场景； 缺点：要考虑Redis的持久化问题，Redis支持RDB和AOF两种持久化的方式。 RDB会定时打一个快照，如果打完快照后，连续自增了几次，还没来得及做下一次快照持久化，此时Redis挂掉了，重启Redis后会出现ID重复的情况。 AOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现ID重复的情况，但是由于incr命令的特殊性，会导致Redis重启恢复数据时间过长。 三、雪花算法 - Snowflake 1. 概述 Twitter的分布式ID生成算法，开源后广受国内大厂的好评，经测试snowflake每秒能够生产26万个自增可排序的ID。 特点： 生成结果是一个64bit大小的Long类型整数； 生成ID能够按照时间有序生成； 不会产生ID碰撞并且效率较高。 2. 结构 结构：符号位（1bit）+ 时间戳（41bit）+ 机器ID（5bit）+ 数据中心（5bit）+ 自增序列号（12bit） 符号位：Java中Long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0； 时间戳：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L 60 60 24 365) = 69年； 工作机器ID：用来记录工作机器ID。可以部署 2^{10} = 1024个节点，包括5位datacenterId和5位workerId。可以灵活配置，机房或者机器号组合都可以； 序列号：自增值，支持同一毫秒内同一个节点（同一个机器）可以生成4096个ID。 因为时间戳是递增的，序列号也是递增的，所以雪花算法可以保证所有生成的ID按时间趋势递增，整个分布式系统内不会产生重复ID（因为有 datacenterId 和 workId来做区分）。 3. 源码 Java版(Hutool)： /** * Twitter的Snowflake 算法 * 分布式系统中，有一些需要使用全局唯一ID的场景，有些时候我们希望能使用一种简单一些的ID，并且希望ID能够按照时间有序生成。 * * * snowflake的结构如下(每部分用-分开): * * * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 * * * 第一位为未使用(符号位表示正数)，接下来的41位为毫秒级时间(41位的长度可以使用69年) * 然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点） * 最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号） * * 并且可以通过生成的id反推出生成时间,datacenterId和workerId * * 参考：http://www.cnblogs.com/relucent/p/4955340.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990`/* * @author Looly ``* @since 3.0.1 */ ``public class Snowflake implements Serializable &#123; private static final long serialVersionUID = 1L; // 开始时间戳 private final long twepoch; // 机器标识位数 private final long workerIdBits = 5L; // 数据中心标识位数 private final long dataCenterIdBits = 5L; // 最大支持机器节点数0~31，一共32个 最大支持数据中心节点数0~31，一共32个 @SuppressWarnings(&#123;&quot;PointlessBitwiseExpression&quot;, &quot;FieldCanBeLocal&quot;&#125;) private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); @SuppressWarnings(&#123;&quot;PointlessBitwiseExpression&quot;, &quot;FieldCanBeLocal&quot;&#125;) private final long maxDataCenterId = -1L ^ (-1L &lt;&lt; dataCenterIdBits); // 序列号12位 private final long sequenceBits = 12L; // 机器节点左移12位 private final long workerIdShift = sequenceBits; // 数据中心节点左移17位 private final long dataCenterIdShift = sequenceBits + workerIdBits; // 时间毫秒数左移22位 private final long timestampLeftShift = sequenceBits + workerIdBits + dataCenterIdBits; @SuppressWarnings(&#123;&quot;PointlessBitwiseExpression&quot;, &quot;FieldCanBeLocal&quot;&#125;) private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);// 4095 private final long workerId; private final long dataCenterId; private final boolean useSystemClock; private long sequence = 0L; private long lastTimestamp = -1L; /** * 构造 * * @param workerId 终端ID * @param dataCenterId 数据中心ID */ public Snowflake(long workerId, long dataCenterId) &#123; this(workerId, dataCenterId, false); &#125; /** * 构造 * * @param workerId 终端ID * @param dataCenterId 数据中心ID * @param isUseSystemClock 是否使用 &#123;@link SystemClock&#125; 获取当前时间戳 */ public Snowflake(long workerId, long dataCenterId, boolean isUseSystemClock) &#123; this(null, workerId, dataCenterId, isUseSystemClock); &#125; /** * @param epochDate 初始化时间起点（null表示默认起始日期）,后期修改会导致id重复,如果要修改连workerId dataCenterId，慎用 * @param workerId 工作机器节点id * @param dataCenterId 数据中心id * @param isUseSystemClock 是否使用&#123;@link SystemClock&#125; 获取当前时间戳 * @since 5.1.3 */ public Snowflake(Date epochDate, long workerId, long dataCenterId, boolean isUseSystemClock) &#123; if (null != epochDate) &#123; this.twepoch = epochDate.getTime(); &#125; else &#123; // Thu, 04 Nov 2010 01:42:54 GMT this.twepoch = 1288834974657L; &#125; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format(&quot;worker Id can&#x27;t be greater than &#123;&#125;&#125; or less than 0&quot;, maxWorkerId)); &#125; if (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; 0) &#123; throw new IllegalArgumentException(String.format(&quot;datacenter Id can&#x27;t be greater than &#123;&#125; or less than 0&quot;, maxDataCenterId)); &#125; this.workerId = workerId; this.dataCenterId = dataCenterId; this.useSystemClock = isUseSystemClock; &#125; /** * 根据Snowflake的ID，获取机器id * * @param id snowflake算法生成的id * @return 所属机器的id */ public long getWorkerId(long id) &#123; return id &gt;&gt; workerIdShift &amp; ~(-1L &lt;&lt; workerIdBits); &#125; /** * 根据Snowflake的ID，获取数据中心id * * @param id snowflake算法生成的id * @return 所属数据中心 */ public long getDataCenterId(long id) &#123; return id &gt;&gt; dataCenterIdShift &amp; ~(-1L &lt;&lt; dataCenterIdBits); &#125; /** * 根据Snowflake的ID，获取生成时间 * * @param id snowflake算法生成的id * @return 生成的时间 */ public long getGenerateDateTime(long id) &#123; return (id &gt;&gt; timestampLeftShift &amp; ~(-1L &lt;&lt; 41L)) + twepoch; &#125; /** * 下一个ID * * @return ID */ public synchronized long nextId() &#123; long timestamp = genTime(); if (timestamp &lt; lastTimestamp) &#123; // 如果服务器时间有问题(时钟后退) 报错。 throw new IllegalStateException(String.format(&quot;Clock moved backwards. Refusing to generate id for &#123;&#125;ms&quot;, (lastTimestamp - timestamp))); &#125; if (lastTimestamp == timestamp) &#123; sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) &#123; timestamp = tilNextMillis(lastTimestamp); &#125; &#125; else &#123; sequence = 0L; &#125; lastTimestamp = timestamp; return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (dataCenterId &lt;&lt; dataCenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; &#125; /** * 下一个ID（字符串形式） * * @return ID 字符串形式 */ public String nextIdStr() &#123; return Long.toString(nextId()); &#125; // ------------------------------------------------------------------------------------------------------------------------------------ Private method start /** * 循环等待下一个时间 * * @param lastTimestamp 上次记录的时间 * @return 下一个时间 */ private long tilNextMillis(long lastTimestamp) &#123; long timestamp = genTime(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = genTime(); &#125; return timestamp; &#125; /** * 生成时间戳 * * @return 时间戳 */ private long genTime() &#123; return this.useSystemClock ? SystemClock.now() : System.currentTimeMillis(); &#125; &#125;` 4. 工程落地经验 分布式整合雪花算法： IdGenerateInvoker.java /** * 分布式环境下数据库主键的ID生成器 * 实现了对分布式友好的Snowflake算法，并且会在Spring IOC容器初始化的时候注册成为单例Bean. * 如果需要自定义生成策略，请实现本接口并将其实例注册到容器中，并在{@link PrimaryKey}的strategy属性指定. * / public interface IdGenerateInvoker { /* * 获取下一个永不重复的id. * * @return id. */ Serializable nextId(); } SnowFlakeIdGenerateInvoker.java /** * ======分布式数据库主键ID生成器基于SnowFlake算法的实现. * 本实现类的对象将会在程序启动的时候自动在Spring IOC容器中注册为Bean. * 如果想在您的持久化过程中由系统自动设置主键字段的值，只需要在具体的POJO字段上添加@PrimaryKey注解，详见{@link PrimaryKey}. * 其默认打开，并且在未指定具体id生成算法的前提下，它将自动使用SnowFlake算法生成id,在持久化之前自动设置值. * * SnowFlake算法的实现依赖于workerId和dataCenterId两个值的，系统默认使用5L作为其初始值. * 如果您想要在分布式环境使用本算法的实现，建议您在application.yml中配置这2个属性的值. */ @Component public class SnowFlakeIdGenerateInvoker implements IdGenerateInvoker { @Autowired private SnowFlakeConfig snowFlakeConfig; private Snowflake snowflake; @PostConstruct public void init() { long wokerid = snowFlakeConfig.getWorkerId(); long dataCenterId = snowFlakeConfig.getDataCenterId(); this.snowflake = new Snowflake(wokerid, dataCenterId); } @Override public synchronized Serializable nextId() { return snowflake.nextId(); } } SnowFlakeConfig.java 公司workerId使用位长为8位，取的是机器IP地址后三位； dataCenterId使用位长为两位，配置在配置文件中。 /** * 关于SnowFlake的配置. * WorkerId和DataCenterId的值请保证集群中的每个节点不相同. * WorkerId取ip地址最后三位，dataCenterId配置在properties. */ @Component @Validated @Slf4j @ConfigurationProperties(prefix = “snowflake”) public class SnowFlakeConfig { @Value(“${spring.application.name}”) private String appName; private long workerId; @NotNull private long dataCenterId; @PostConstruct public void init() { try { String ipAddr = NetUtil.getHostIpAddr(); log.info(“current ip :{}”, ipAddr); if (!StringUtils.isEmpty(ipAddr)) { String[] ipStep = ipAddr.split(“\\.”); this.workerId = Long.valueOf(ipStep[3]); } else { log.warn(“ip address parse error.”); } } catch (Exception e) { throw new RuntimeException(e); } log.info(“Snowflake:[workerId:{} from ip address tail, dataCenterId:{} from properties] of micro service [{}] has been initialized.” , workerId, dataCenterId, appName == null ? “” : appName.toUpperCase()); } public long getWorkerId() { return workerId; } public void setWorkerId(long workerId) { this.workerId = workerId; } public long getDataCenterId() { return dataCenterId; } public void setDataCenterId(long dataCenterId) { this.dataCenterId = dataCenterId; } } application.properties spring.application.name=ncs-case # snowflake配置 #snowflake.worker-id= snowflake.data-center-id=2 5. 雪花算法优缺点 优点： 毫秒数在高位，自增序列在低位，整个ID都是趋势递增的； 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的； 可以根据自身业务特性分配bit位，非常灵活。 缺点： 依赖机器时钟，如果机器时钟回拨，会导致重复ID生成； 在单机上是递增的，但是由于设计到分布式环境，每台机器上的时钟不可能完全同步，有时候会出现不是全局递增的情况（此缺点可以认为无所谓，一般分布式ID只要求趋势递增，并不会严格要求递增，90%的需求都只要求趋势递增）。 补充解决时钟回拨思路：因为机器的原因会发生时间回拨，我们的雪花算法是强依赖机器时间的，如果时间发生回拨，有可能会生成重复的ID，在我们上面的nextId中用当前时间和上一次的时间进行判断，如果当前时间小于上一次的时间那么肯定是发生了回拨，普通的算法会直接抛出异常。这里我们可以对其进行优化，一般分为两个情况： 如果时间回拨时间较短，比如配置5ms以内，那么可以直接等待一定的时间，让机器时间追上来； 如果时间的回拨时间较长，我们不能接受这么长的阻塞等待，那么又有两个策略，直接拒绝，抛出异常，打日志，或者通知RD时钟回滚。 四、其他方式 百度开源的分布式唯一ID生成器UidGenerator 美团点评分布式ID生成系统 Leaf","categories":[{"name":"分布式","slug":"分布式","permalink":"http://blog.binvon.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://blog.binvon.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"Java两种方式实现Token校验","slug":"Java实现基于token认证的方法示例","date":"2017-06-08T01:11:22.000Z","updated":"2017-06-10T15:03:42.000Z","comments":true,"path":"2017/06/08/Java实现基于token认证的方法示例/","link":"","permalink":"http://blog.binvon.com/2017/06/08/Java%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8Etoken%E8%AE%A4%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B/","excerpt":"","text":"一、与cookie相比较的优势： 1、支持跨域访问，将token置于请求头中，而cookie是不支持跨域访问的； 2、无状态化，服务端无需存储token，只需要验证token信息是否正确即可，而session需要在服务端存储，一般是通过cookie中的sessionID在服务端查找对应的session； 3、无需绑定到一个特殊的身份验证方案（传统的用户名密码登陆），只需要生成的token是符合我们预期设定的即可； 4、更适用于移动端（Android，iOS，小程序等等），像这种原生平台不支持cookie，比如说微信小程序，每一次请求都是一次会话，当然我们可以每次去手动为他添加cookie，详情请查看博主另一篇博客； 5、避免CSRF跨站伪造攻击，还是因为不依赖cookie； 6、非常适用于RESTful API,这样可以轻易与各种后端（java，.net，python……）相结合，去耦合 还有一些优势这里就不一一列举了。 二、基于JWT的token认证实现 JWT：JSON Web Token，其实token就是一段字符串，由三部分组成：Header，Payload，Signature。详细情况请自行百度，现在，上代码。 1、引入依赖，这里选用java-jwt，选择其他的依赖也可以 2、实现签名方法 设置15分钟过期也是出于安全考虑，防止token被窃取，不过一般选择基于token认证，传输方式我们都应该选择https，这样别人无法抓取到我们的请求信息。这个私钥是非常重要的，加密解密都需要用到它，要设置的足够复杂并且不能被盗取，我这里选用的是一串uuid，加密方式是HMAC256。 3、认证 我这里演示的还是以传统的用户名密码验证，验证通过发放token。 **4、配置拦截器 实现HandleInterceptor，重写preHandle方法，该方法是在每个请求之前触发执行，从request的头里面取出token，这里我们统一了存放token的键为accessToken，验证通过，放行，验证不通过，返回认证失败信息。 5、设置拦截器 这里使用的是Spring的xml配置拦截器，放过认证接口。 6、token解码方法 7、测试 访问携带token，请求成功。 未携带token或者token错误，过期，返回认证失败信息。 8、获取token里携带的信息 我们可以将一些常用的信息放入token中，比如用户登陆信息，可以方便我们的使用 至此，一个简单的基于token认证就实现了.","categories":[{"name":"auth","slug":"auth","permalink":"http://blog.binvon.com/categories/auth/"}],"tags":[{"name":"auth","slug":"auth","permalink":"http://blog.binvon.com/tags/auth/"}]},{"title":"cron表达式详解","slug":"cron表达式详解","date":"2016-10-06T04:11:22.000Z","updated":"2016-10-17T12:03:42.000Z","comments":true,"path":"2016/10/06/cron表达式详解/","link":"","permalink":"http://blog.binvon.com/2016/10/06/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式： Seconds Minutes Hours DayofMonth Month DayofWeek Year或 Seconds Minutes Hours DayofMonth Month DayofWeek 每一个域可出现的字符如下： Seconds:可出现”, - * /“四个字符，有效范围为0-59的整数 Minutes:可出现”, - * /“四个字符，有效范围为0-59的整数 Hours:可出现”, - * /“四个字符，有效范围为0-23的整数 DayofMonth:可出现”, - * / ? L W C”八个字符，有效范围为0-31的整数 Month:可出现”, - * /“四个字符，有效范围为1-12的整数或JAN-DEc DayofWeek:可出现”, - * / ? L C #”四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一， 依次类推 Year:可出现”, - * /“四个字符，有效范围为1970-2099年 每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是： (1)：表示匹配该域的任意值，假如在Minutes域使用, 即表示每分钟都会触发事件。 (2)?:只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和 DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用，如果使用表示不管星期几都会触发，实际上并不是这样。 (3)-:表示范围，例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 (4)/：表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. (5),:表示列出枚举值值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 (6)L:表示最后，只能出现在DayofWeek和DayofMonth域，如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 (7)W: 表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一 到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 (8)LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 (9)#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。 举几个例子: 0 0 2 1 * ? * 表示在每月的1日的凌晨2点调度任务 0 15 10 ? * MON-FRI 表示周一到周五每天上午10：15执行作业 0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作 一个cron表达式有至少6个（也可能7个）有空格分隔的时间元素。 按顺序依次为 秒（0~59） 分钟（0~59） 小时（0~23） 天（月）（0~31，但是你需要考虑你月的天数） 月（0~11） 天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT） 年份（1970－2099） 其中每个元素可以是一个值(如6),一个连续区间(9-12),一个间隔时间(8-18/4)(/表示每隔4小时),一个列表(1,3,5),通配符。由于”月份中的日期”和”星期中的日期”这两个元素互斥的,必须要对其中一个设置? 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 0 0 12 ? * WED 表示每个星期三中午12点 “0 0 12 * * ?” 每天中午12点触发 “0 15 10 ? * *” 每天上午10:15触发 “0 15 10 * * ?” 每天上午10:15触发 “0 15 10 * * ? *” 每天上午10:15触发 “0 15 10 * * ? 2005” 2005年的每天上午10:15触发 “0 * 14 * * ?” 在每天下午2点到下午2:59期间的每1分钟触发 “0 0/5 14 * * ?” 在每天下午2点到下午2:55期间的每5分钟触发 “0 0/5 14,18 * * ?” 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 “0 0-5 14 * * ?” 在每天下午2点到下午2:05期间的每1分钟触发 “0 10,44 14 ? 3 WED” 每年三月的星期三的下午2:10和2:44触发 “0 15 10 ? * MON-FRI” 周一至周五的上午10:15触发 “0 15 10 15 * ?” 每月15日上午10:15触发 “0 15 10 L * ?” 每月最后一日的上午10:15触发 “0 15 10 ? * 6L” 每月的最后一个星期五上午10:15触发 “0 15 10 ? * 6L 2002-2005” 2002年至2005年的每月的最后一个星期五上午10:15触发 “0 15 10 ? * 6#3” 每月的第三个星期五上午10:15触发 有些子表达式能包含一些范围或列表 例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT” “*”字符代表所有可能的值 因此，“”在子表达式（月）里表示每个月的含义，“”在子表达式（天（星期））表示星期的每一天 “/”字符用来指定数值的增量 例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟 在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样 “？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值 当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？” “L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写 但是它在两个子表达式里的含义是不同的。 在天（月）子表达式中，“L”表示一个月的最后一天 在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT 如果在“L”前有具体的内容，它就具有其他的含义了 例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题 字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日期 1-31 , - * ? / L W C 月份 1-12 或者 JAN-DEC , - * / 星期 1-7 或者 SUN-SAT , - * ? / L C # 年（可选） 留空, 1970-2099 , - * / 2）Cron表达式范例： ​ 每隔5秒执行一次：*/5 * * * * ? ​ 每隔1分钟执行一次：0 */1 * * * ? ​ 每天23点执行一次：0 0 23 * * ? ​ 每天凌晨1点执行一次：0 0 1 * * ? ​ 每月1号凌晨1点执行一次：0 0 1 1 * ? ​ 每月最后一天23点执行一次：0 0 23 L * ? ​ 每周星期天凌晨1点实行一次：0 0 1 ? * L ​ 在26分、29分、33分执行一次：0 26,29,33 * * * ? ​ 每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?","categories":[{"name":"springMvc","slug":"springMvc","permalink":"http://blog.binvon.com/categories/springMvc/"}],"tags":[{"name":"Quartz","slug":"Quartz","permalink":"http://blog.binvon.com/tags/Quartz/"}]},{"title":"SpringMvc中使用Task实现定时任务","slug":"SpringMvc中使用Task实现定时任务","date":"2016-10-05T04:11:22.000Z","updated":"2016-10-10T12:03:42.000Z","comments":true,"path":"2016/10/05/SpringMvc中使用Task实现定时任务/","link":"","permalink":"http://blog.binvon.com/2016/10/05/SpringMvc%E4%B8%AD%E4%BD%BF%E7%94%A8Task%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"Spring中实现定时任务其实很简单，可以使用spring中自带的task 相当于轻量级的Quartz，并且spring 3.0 之后支持注解的方式，使用起来非常简单，方便，具体实现如下： 第一步，修改spring.xml配置文件 在xsi:schemaLocation中加入 http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd 同时加入 xmlns:task=”http://www.springframework.org/schema/task 第二步，开启task注解 1 task:annotation-driven/ 第三步，编写作业类，并在作业类中加入注解 123456789@Component(&quot;myTask&quot;) @Lazy(false) public class MyTask &#123; @Scheduled(cron=&quot;0/5 * * * * ?&quot;) public void run()&#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(sdf.format(new Date()) + &quot;定时任务执行&quot;); &#125; &#125; 注意：使用Lazy注解是因为spring 配置文件采用懒加载的原因default-lazy-init=”true” 这个配置会导致 @Scheduled失效","categories":[{"name":"springMvc","slug":"springMvc","permalink":"http://blog.binvon.com/categories/springMvc/"}],"tags":[{"name":"Quartz","slug":"Quartz","permalink":"http://blog.binvon.com/tags/Quartz/"}]},{"title":"springMvc里的mvc_resources与静态资源的访问","slug":"springMvc里的mvc-resources与静态资源的访问","date":"2016-09-04T18:11:22.000Z","updated":"2016-09-10T15:03:42.000Z","comments":true,"path":"2016/09/05/springMvc里的mvc-resources与静态资源的访问/","link":"","permalink":"http://blog.binvon.com/2016/09/05/springMvc%E9%87%8C%E7%9A%84mvc-resources%E4%B8%8E%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/","excerpt":"","text":"在进行Spring MVC的配置时，通常我们会配置一个dispatcher servlet用于处理对应的URL。配置如下： 12345678910&lt;servlet&gt;&lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 这表示名字为mvc-dispatcher的servlet会处理一切的url对应的请求，那么我们怎么让servlet来处理项目中的静态资源呢？这里有两种方法。 另外使用一个servlet来处理静态资源。若我们的资源放置在webapps文件夹下的resources文件夹中，那么我们可以用名字为default的servlet来处理静态资源。因此我们还需要在上述配置的基础上加上以下配置： 1234&lt;servlet-mapping&gt;&lt;servlet-name&gt;default&lt;/servlet-name&gt;&lt;url-pattern&gt;resources/* &lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 这表示default的servlet会处理url中为resources/*的对应的请求。这样，当你把你的image，css已经其他文件放在resources文件中时，spring就可以找到它啦。 采用spring自带mvc:resources方法。首先找到你定义的那个servlet的xml文件，如本例子中，servlet的名字叫mvc-dispatcher，因此需要找到mvc-dispatcher-servlet.xml文件，并在该文件中插入以下配置： 12&lt;mvc:annotation-driven/&gt;&lt;mvc:resources mapping=&quot;/resources/**/&quot; location=&quot;/resources/&quot;/&gt; 这样，就不必另外添加一个mvc来处理静态资源。而mvc知道静态资源所处的位置为resources文件夹。 两种方法都可以将spring mvc配置处理静态资源。 在SpringMVC3.0之后推荐使用一： 123&lt;!-- 静态资源访问 --&gt; &lt;mvc:default-servlet-handler/&gt; 以下两种在SpringMVC3.0之前可以使用 也可以使用二： 12345&lt;!-- 静态资源访问 &lt;mvc:resources location=&quot;/img/&quot; mapping=&quot;/img/**&quot;/&gt; &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt; &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt;--&gt; 也可以使用三： web.xml里添加如下的配置 1234567891011121314151617181920&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.gif&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;","categories":[{"name":"springMvc","slug":"springMvc","permalink":"http://blog.binvon.com/categories/springMvc/"}],"tags":[{"name":"springMvc","slug":"springMvc","permalink":"http://blog.binvon.com/tags/springMvc/"}]},{"title":"MySQL的排序规则","slug":"MySQL的排序规则","date":"2016-05-05T01:11:22.000Z","updated":"2016-05-10T15:03:42.000Z","comments":true,"path":"2016/05/05/MySQL的排序规则/","link":"","permalink":"http://blog.binvon.com/2016/05/05/MySQL%E7%9A%84%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99/","excerpt":"","text":"一、对比 1、utf8_general_ci 不区分大小写， utf8_general_cs 区分大小写 2、utf8_bin: compare strings by the binary value of each character in the string 将字符串每个字符串用二进制数据编译存储，区分大小写，而且可以存二进制的内容。 3、utf8_unicode_ci校对规则仅部分支持Unicode校对规则算法,一些字符还是不能支持；utf8_unicode_ci不能完全支持组合的记号。 说明：ci是 case insensitive, 即 “大小写不敏感”, a 和 A 会在字符判断中会被当做一样的。bin 是二进制, a 和 A 会别区别对待。例如你运行:SELECT * FROM table WHERE txt = ‘a’，那么在utf8_bin中你就找不到 txt = ‘A’ 的那一行, 而 utf8_general_ci 则可以。utf8_general_ci是一个遗留的 校对规则，不支持扩展，它仅能够在字符之间进行逐个比较。这意味着utf8_general_ci校对规则进行的比较速度很快，但是与使用 utf8_unicode_ci的校对规则相比，比较正确性较差。 二、应用上的差别 1、对于一种语言仅当使用utf8_unicode_ci排序做的不好时，才执行与具体语言相关的utf8字符集校对规则。例如，对于德语和法语，utf8_unicode_ci工作的很好，因此不再需要为这两种语言创建特殊的utf8校对规则。 2、utf8_general_ci也适用与德语和法语，除了‘?’等于‘s’，而不是‘ss’之外。如果你的应用能够接受这些，那么应该使用 utf8_general_ci，因为它速度快。否则，使用utf8_unicode_ci，因为它比较准确。 三、使用 utf8_unicode_ci比较准确，utf8_general_ci速度比较快。通常情况下，新建数据库时一般选用utf8_general_ci就可以了。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.binvon.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.binvon.com/tags/mysql/"}]},{"title":"警告_Establishing-SSL-connection-without-server’s-identity-verification-is-not-recommended","slug":"警告-Establishing-SSL-connection-without-server’s-identity-verification-is-not-recommended","date":"2016-04-07T04:19:36.000Z","updated":"2016-04-10T15:03:42.000Z","comments":true,"path":"2016/04/07/警告-Establishing-SSL-connection-without-server’s-identity-verification-is-not-recommended/","link":"","permalink":"http://blog.binvon.com/2016/04/07/%E8%AD%A6%E5%91%8A-Establishing-SSL-connection-without-server%E2%80%99s-identity-verification-is-not-recommended/","excerpt":"","text":"SpringBoot启东时红色警告： Mon Jun 04 00:53:48 CST 2018 WARN: Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification 翻译： 请注意:不建议在没有服务器身份验证的情况下建立SSL连接。根据MySQL 5.5.45+、5.6.26+和5.7.6+的要求，如果不设置显式选项，则必须建立默认的SSL连接。您需要通过设置useSSL=false显式地禁用SSL，或者设置useSSL=true并为服务器证书验证提供信任存储 解决方法： jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false","categories":[{"name":"持久层","slug":"持久层","permalink":"http://blog.binvon.com/categories/%E6%8C%81%E4%B9%85%E5%B1%82/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.binvon.com/tags/mysql/"}]},{"title":"java中获取昨天的当前日期","slug":"java中获取昨天的当前日期","date":"2016-01-05T04:11:22.000Z","updated":"2016-01-10T12:03:42.000Z","comments":true,"path":"2016/01/05/java中获取昨天的当前日期/","link":"","permalink":"http://blog.binvon.com/2016/01/05/java%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%98%A8%E5%A4%A9%E7%9A%84%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F/","excerpt":"","text":"在java里，获取昨天的当前日期，可以采用calendar来做，也可以采用date来做；如下： 1.采用calendar来做： 12345Calendar cal=Calendar.getInstance();//System.out.println(Calendar.DATE);//5cal.add(Calendar.DATE,-1);Date time=cal.getTime();System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).format(time)); 2.采用date来做： 12345678Date today = new Date();/* System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).format(today));System.out.println(today.getTime());System.out.println(1477058241633L-86400000L);*/Date yesterday = new Date(today.getTime() - 86400000L);//86400000L，它的意思是说1天的时间=24小时 x 60分钟 x 60秒 x 1000毫秒 单位是L。//即86400000L可用写成 24*60*60*1000L//System.out.println(24*60*60*1000L);System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).format(yesterday)); 在数据库里也可以的，获取当前时间 now或者sysdate，获取昨天当前时刻日期： 123select DATEADD(day, 1, NOW);-- 在sqlserver中select date_sub(current_date(),interval 1 day)-- 在mysql中select sysdate - interval &#x27;1&#x27; day from dual;-- 在oracle中","categories":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/tags/java/"}]},{"title":"can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1","slug":"can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-at-line-4-column-1","date":"2015-09-10T08:00:11.000Z","updated":"2015-09-10T15:03:42.000Z","comments":true,"path":"2015/09/10/can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-at-line-4-column-1/","link":"","permalink":"http://blog.binvon.com/2015/09/10/can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-at-line-4-column-1/","excerpt":"","text":"无法读取块映射项;多行键可能不是第4行第1列的隐式键: 我是新建一篇博客时、编译出现的错误。其实我之前一直不配置tags的。这里的”:”后面还是要接上空格。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.binvon.com/categories/hexo/"}],"tags":[{"name":"bug","slug":"bug","permalink":"http://blog.binvon.com/tags/bug/"}]},{"title":"BIO,NIO,AIO 有什么区别","slug":"BIO-NIO-AIO-有什么区别","date":"2015-08-04T18:11:22.000Z","updated":"2015-08-10T15:03:42.000Z","comments":true,"path":"2015/08/05/BIO-NIO-AIO-有什么区别/","link":"","permalink":"http://blog.binvon.com/2015/08/05/BIO-NIO-AIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","excerpt":"","text":"BIO （Blocking I/O）：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。这里使用那个经典的烧开水例子，这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。 NIO （New I/O）：同时支持阻塞与非阻塞模式，但这里我们以其同步非阻塞I/O模式来说明，那么什么叫做同步非阻塞？如果还拿烧开水来说，NIO的做法是叫一个线程不断的轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。 AIO （ Asynchronous I/O）：异步非阻塞I/O模型。异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。 进程中的IO调用步骤大致可以分为以下四步： 进程向操作系统请求数据 ; 操作系统把外部数据加载到内核的缓冲区中; 操作系统把内核的缓冲区拷贝到进程的缓冲区 ; 进程获得数据完成自己的功能 ; 当操作系统在把外部数据放到进程缓冲区的这段时间（即上述的第二，三步），如果应用进程是挂起等待的，那么就是同步IO，反之，就是异步IO，也就是AIO 。","categories":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/categories/java/"}],"tags":[{"name":"I/O","slug":"I-O","permalink":"http://blog.binvon.com/tags/I-O/"}]},{"title":"continue,break,return有什么区别","slug":"continue-break-return有什么区别","date":"2015-07-11T18:23:42.000Z","updated":"2015-07-12T15:03:42.000Z","comments":true,"path":"2015/07/12/continue-break-return有什么区别/","link":"","permalink":"http://blog.binvon.com/2015/07/12/continue-break-return%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1、return ：直接跳出当前的方法,返回到该调用的方法的语句处,继续执行 2、break：在循环体内结束整个循环过程 3、continue ：结束本次的循环，直接进行下一次的循环","categories":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/tags/java/"}]},{"title":"CentOS7查看最大线程数","slug":"CentOS7查看最大线程数","date":"2015-07-10T08:23:43.000Z","updated":"2019-10-22T15:03:42.000Z","comments":true,"path":"2015/07/10/CentOS7查看最大线程数/","link":"","permalink":"http://blog.binvon.com/2015/07/10/CentOS7%E6%9F%A5%E7%9C%8B%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%95%B0/","excerpt":"","text":"aaaa","categories":[{"name":"服务器","slug":"服务器","permalink":"http://blog.binvon.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://blog.binvon.com/tags/linux/"}]},{"title":"JDK安装与环境变量配置","slug":"JDK安装与环境变量配置","date":"2015-07-10T08:23:43.000Z","updated":"2015-07-10T15:03:42.000Z","comments":true,"path":"2015/07/10/JDK安装与环境变量配置/","link":"","permalink":"http://blog.binvon.com/2015/07/10/JDK%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/","excerpt":"","text":"工具/原料 JDK1.7.0 WIN7 方法/步骤 一、安装JDK 选择安装目录 安装过程中会出现两次 安装提示 。第一次是安装 jdk ，第二次是安装 jre 。 建议两个都安装在同一个java文件夹中的不同文件夹中。 （不能都安装在java文件夹的根目录下，jdk和jre安装在同一文件夹会出错）如下图所示 二、1：安装jdk 随意选择目录 只需把默认安装目录 \\java 之前的目录修改即可 2：安装jre→更改→ \\java 之前目录和安装 jdk 目录相同即可 注：若无安装目录要求，可全默认设置。无需做任何修改，两次均直接点下一步。 三、安装完JDK后配置环境变量 计算机→属性→高级系统设置→高级→环境变量 四、系统变量→新建 JAVA_HOME 变量 。 变量值填写jdk的安装目录（本人是 E:\\Java\\jdk1.7.0)五、系统变量→寻找 Path 变量→编辑 在变量值最后输入 %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; （注意原来Path的变量值末尾有没有;号，如果没有，先输入；号再输入上面的代码） 六、系统变量→新建 CLASSPATH 变量 变量值填写 .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar（注意最前面有一点） 系统变量配置完毕 七、检验是否配置成功 运行cmd 输入 java -version （java 和 -version 之间有空格） 若如图所示 显示版本信息 则说明安装和配置成功。","categories":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/tags/java/"}]}],"categories":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/categories/java/"},{"name":"分布式","slug":"分布式","permalink":"http://blog.binvon.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"服务器","slug":"服务器","permalink":"http://blog.binvon.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"vpn","slug":"vpn","permalink":"http://blog.binvon.com/categories/vpn/"},{"name":"持久层","slug":"持久层","permalink":"http://blog.binvon.com/categories/%E6%8C%81%E4%B9%85%E5%B1%82/"},{"name":"缓存","slug":"缓存","permalink":"http://blog.binvon.com/categories/%E7%BC%93%E5%AD%98/"},{"name":"auth","slug":"auth","permalink":"http://blog.binvon.com/categories/auth/"},{"name":"springMvc","slug":"springMvc","permalink":"http://blog.binvon.com/categories/springMvc/"},{"name":"数据库","slug":"数据库","permalink":"http://blog.binvon.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.binvon.com/categories/hexo/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.binvon.com/tags/java/"},{"name":"springcloud","slug":"springcloud","permalink":"http://blog.binvon.com/tags/springcloud/"},{"name":"consul","slug":"consul","permalink":"http://blog.binvon.com/tags/consul/"},{"name":"linux","slug":"linux","permalink":"http://blog.binvon.com/tags/linux/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://blog.binvon.com/tags/shadowsocks/"},{"name":"mybatis","slug":"mybatis","permalink":"http://blog.binvon.com/tags/mybatis/"},{"name":"websocket","slug":"websocket","permalink":"http://blog.binvon.com/tags/websocket/"},{"name":"redis","slug":"redis","permalink":"http://blog.binvon.com/tags/redis/"},{"name":"多线程","slug":"多线程","permalink":"http://blog.binvon.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"分布式","slug":"分布式","permalink":"http://blog.binvon.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"auth","slug":"auth","permalink":"http://blog.binvon.com/tags/auth/"},{"name":"Quartz","slug":"Quartz","permalink":"http://blog.binvon.com/tags/Quartz/"},{"name":"springMvc","slug":"springMvc","permalink":"http://blog.binvon.com/tags/springMvc/"},{"name":"mysql","slug":"mysql","permalink":"http://blog.binvon.com/tags/mysql/"},{"name":"bug","slug":"bug","permalink":"http://blog.binvon.com/tags/bug/"},{"name":"I/O","slug":"I-O","permalink":"http://blog.binvon.com/tags/I-O/"}]}